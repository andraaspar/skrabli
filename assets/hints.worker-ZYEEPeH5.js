(function(){"use strict";var Direction=(Direction2=>(Direction2[Direction2.Horizontal=0]="Horizontal",Direction2[Direction2.Vertical=1]="Vertical",Direction2))(Direction||{});function boardIsEmpty(board){for(const field of board)if(field.tile)return!1;return!0}function getFieldIndexOffset(direction,boardSize){return direction===Direction.Horizontal?1:boardSize.width}function getColumnIndex(fieldIndex,boardSize){return fieldIndex%boardSize.width}function getColumnLine(board,boardSize,columnIndex){const column=[];for(let rowIndex=0;rowIndex<boardSize.height;rowIndex++)column.push(board[rowIndex*boardSize.width+columnIndex]);return column}function getRowIndex(fieldIndex,boardSize){return Math.floor(fieldIndex/boardSize.width)}function getRowLine(board,boardSize,lineIndex){const firstFieldIndex=lineIndex*boardSize.width;return board.slice(firstFieldIndex,firstFieldIndex+boardSize.width)}function getWordFromLine(line,lineIndex){const word=[];let index=lineIndex,startLineIndex=lineIndex,endLineIndex=lineIndex;for(;index>=0;){const field=line[index];if(!field.tile)break;word.unshift(field),startLineIndex=index,index--}for(index=lineIndex+1;index<line.length;){const field=line[index];if(!field||!field.tile)break;word.push(field),endLineIndex=index,index++}return{word:word.length>1?word:[],startLineIndex,endLineIndex}}function getWordAt(board,boardSize,fieldIndex,direction){return direction===Direction.Horizontal?getWordFromLine(getRowLine(board,boardSize,getRowIndex(fieldIndex,boardSize)),getColumnIndex(fieldIndex,boardSize)):getWordFromLine(getColumnLine(board,boardSize,getColumnIndex(fieldIndex,boardSize)),getRowIndex(fieldIndex,boardSize))}function theOtherDirection(d){return d===Direction.Horizontal?Direction.Vertical:Direction.Horizontal}function getAllOwnedWords(board,boardSize,{firstFieldIndex,lastFieldIndex,direction}){const words=[];if(firstFieldIndex!=null&&lastFieldIndex!=null&&direction!=null){words.push(getWordAt(board,boardSize,firstFieldIndex,direction).word);let fieldIndex=firstFieldIndex,field=board[fieldIndex];for(;field&&field.tile&&(field.tile.isOwned&&words.push(getWordAt(board,boardSize,fieldIndex,theOtherDirection(direction)).word),fieldIndex+=getFieldIndexOffset(direction,boardSize),!(fieldIndex>lastFieldIndex));)field=board[fieldIndex]}return words.filter(_=>_.length>0)}function getLineIndex(fieldIndex,boardSize,direction){return direction===Direction.Horizontal?getRowIndex(fieldIndex,boardSize):getColumnIndex(fieldIndex,boardSize)}const BINGO_SCORE=50,HAND_SIZE=7;var FieldKind=(FieldKind2=>(FieldKind2.Normal="-",FieldKind2.StartNoBonus="S",FieldKind2.Start="s",FieldKind2.DoubleLetter="l",FieldKind2.TripleLetter="L",FieldKind2.DoubleWord="w",FieldKind2.TripleWord="W",FieldKind2))(FieldKind||{});function getWordScore(word){let wordMulti=1;return word.reduce((sum,field)=>{const tile=field.tile;let tileScore=0;if(tile&&(tileScore=tile.score,tile.isOwned))switch(field.kind){case FieldKind.DoubleLetter:tileScore*=2;break;case FieldKind.TripleLetter:tileScore*=3;break;case FieldKind.Start:case FieldKind.DoubleWord:wordMulti*=2;break;case FieldKind.TripleWord:wordMulti*=3;break}return sum+tileScore},0)*wordMulti}function getMoveScore(allOwnedWords,isBingo){let score=0;for(const word of allOwnedWords)score+=getWordScore(word);return isBingo&&(score+=BINGO_SCORE),score}function findStartFieldIndex(board){for(let fieldIndex=0;fieldIndex<board.length;fieldIndex++){const kind=board[fieldIndex].kind;if(kind===FieldKind.Start||kind===FieldKind.StartNoBonus)return fieldIndex}throw new Error("[rycmdu] Start field not found!")}const JOKER_LETTERS=[{letter:" ",count:2,score:0},{letter:"a",count:6,score:1},{letter:"á",count:4,score:1},{letter:"b",count:3,score:2},{letter:"c",count:1,score:5},{letter:"cs",count:1,score:7},{letter:"d",count:3,score:2},{letter:"dz",count:0,score:0},{letter:"dzs",count:0,score:0},{letter:"e",count:6,score:1},{letter:"é",count:3,score:3},{letter:"f",count:2,score:4},{letter:"g",count:3,score:2},{letter:"gy",count:2,score:4},{letter:"h",count:2,score:3},{letter:"i",count:3,score:1},{letter:"í",count:1,score:5},{letter:"j",count:2,score:4},{letter:"k",count:6,score:1},{letter:"l",count:4,score:1},{letter:"ly",count:1,score:8},{letter:"m",count:3,score:1},{letter:"n",count:4,score:1},{letter:"ny",count:1,score:5},{letter:"o",count:3,score:1},{letter:"ó",count:3,score:2},{letter:"ö",count:2,score:4},{letter:"ő",count:1,score:7},{letter:"p",count:2,score:4},{letter:"q",count:0,score:0},{letter:"r",count:4,score:1},{letter:"s",count:3,score:1},{letter:"sz",count:2,score:3},{letter:"t",count:5,score:1},{letter:"ty",count:1,score:10},{letter:"u",count:2,score:4},{letter:"ú",count:1,score:7},{letter:"ü",count:2,score:4},{letter:"ű",count:1,score:7},{letter:"v",count:2,score:3},{letter:"w",count:0,score:0},{letter:"x",count:0,score:0},{letter:"y",count:0,score:0},{letter:"z",count:2,score:4},{letter:"zs",count:1,score:8}].filter(letter=>letter.letter!==" ").map(letter=>letter.letter).sort((a,b)=>b.length-a.length);function getLettersInHand(hand){const letters=new Set;for(const tile of hand){if(tile?.isJoker)return JOKER_LETTERS;tile&&letters.add(tile.letter)}return Array.from(letters)}function getLettersInHandRe(hand){const lettersInHand=getLettersInHand(hand);return lettersInHand.length?`(?:${lettersInHand.join("|")})`:""}function getLineFieldIndex(boardSize,direction,lineIndex,lineFieldIndex){return direction===Direction.Horizontal?lineIndex*boardSize.width+lineFieldIndex:lineFieldIndex*boardSize.width+lineIndex}function range(n){return[...Array(n).keys()]}function getPlacementInfos({fieldOffset,wordParts,hand}){return getPlacementInfoInternal({alignToEnd:!0,fieldOffset,hand,wordParts,handIndices:[],jokerLetters:[]})}function getPlacementInfoInternal({alignToEnd,fieldOffset,wordParts,hand,handIndices,jokerLetters}){if(wordParts.length===0)return[];const result=[],wordPart=wordParts[0];if(wordPart.gapBefore>0)return getPlacementInfoInternal({alignToEnd:!1,fieldOffset,wordParts:[{...wordPart,gapBefore:0},...wordParts.slice(1)],hand,handIndices:[...handIndices,...range(wordPart.gapBefore).map(()=>null)],jokerLetters:[...jokerLetters,...range(wordPart.gapBefore).map(()=>null)]});if(wordPart.text){if(wordPart.fieldCount<1)return[];for(let handIndex=0;handIndex<hand.length;handIndex++){const tile=hand[handIndex];if(tile)if(tile.isJoker)for(const letter of JOKER_LETTERS)wordPart.text.startsWith(letter)&&result.push(...getPlacementInfoInternal({alignToEnd,fieldOffset,wordParts:[{...wordPart,fieldCount:wordPart.fieldCount-1,text:wordPart.text.slice(letter.length)},...wordParts.slice(1)],hand:[...hand.slice(0,handIndex),null,...hand.slice(handIndex+1)],handIndices:[...handIndices,handIndex],jokerLetters:[...jokerLetters,letter]}));else wordPart.text.startsWith(tile.letter)&&result.push(...getPlacementInfoInternal({alignToEnd,fieldOffset,wordParts:[{...wordPart,fieldCount:wordPart.fieldCount-1,text:wordPart.text.slice(tile.letter.length)},...wordParts.slice(1)],hand:[...hand.slice(0,handIndex),null,...hand.slice(handIndex+1)],handIndices:[...handIndices,handIndex],jokerLetters:[...jokerLetters,null]}))}}else{const newFieldOffset=alignToEnd?fieldOffset+wordPart.fieldCount:fieldOffset;return wordParts.length===1?[{handIndices,jokerLetters,fieldOffset:newFieldOffset}]:!alignToEnd&&wordPart.fieldCount>0?[]:getPlacementInfoInternal({alignToEnd:!1,fieldOffset:newFieldOffset,wordParts:wordParts.slice(1),hand,handIndices,jokerLetters})}return result}function isThereAGap(board,boardSize,startFieldIndex,endFieldIndex,direction){for(let fieldIndex=startFieldIndex;fieldIndex<=endFieldIndex;fieldIndex+=getFieldIndexOffset(direction,boardSize))if(!board[fieldIndex]?.tile)return!0;return!1}function getWordInfo(board,boardSize){let firstFieldIndex=null,lastFieldIndex=null,colIndex=null,rowIndex=null,direction=null;for(let fieldIndex=0;fieldIndex<board.length;fieldIndex++){const field=board[fieldIndex];if(field.tile&&field.tile.isOwned)if(colIndex==null)firstFieldIndex=fieldIndex,lastFieldIndex=fieldIndex,colIndex=getColumnIndex(fieldIndex,boardSize),rowIndex=getRowIndex(fieldIndex,boardSize);else{const newColIndex=getColumnIndex(fieldIndex,boardSize),newRowIndex=getRowIndex(fieldIndex,boardSize);lastFieldIndex===firstFieldIndex?colIndex===newColIndex?direction=Direction.Vertical:rowIndex===newRowIndex&&(direction=Direction.Horizontal):(direction===Direction.Vertical&&colIndex!==newColIndex||direction===Direction.Horizontal&&rowIndex!==newRowIndex)&&(direction=null),colIndex=newColIndex,rowIndex=newRowIndex,lastFieldIndex=fieldIndex}}if(firstFieldIndex!=null){const horizontal=getWordAt(board,boardSize,firstFieldIndex,Direction.Horizontal),vertical=getWordAt(board,boardSize,firstFieldIndex,Direction.Vertical);firstFieldIndex===lastFieldIndex&&(horizontal.word.length?direction=Direction.Horizontal:vertical.word.length&&(direction=Direction.Vertical)),direction===Direction.Horizontal?(firstFieldIndex=Math.min(firstFieldIndex,getRowIndex(firstFieldIndex,boardSize)*boardSize.width+horizontal.startLineIndex),lastFieldIndex=Math.max(lastFieldIndex,getRowIndex(firstFieldIndex,boardSize)*boardSize.width+horizontal.endLineIndex)):direction===Direction.Vertical&&(firstFieldIndex=Math.min(firstFieldIndex,vertical.startLineIndex*boardSize.width+getColumnIndex(firstFieldIndex,boardSize)),lastFieldIndex=Math.max(lastFieldIndex,vertical.endLineIndex*boardSize.width+getColumnIndex(firstFieldIndex,boardSize)))}return firstFieldIndex!=null&&lastFieldIndex!=null&&direction!=null&&isThereAGap(board,boardSize,firstFieldIndex,lastFieldIndex,direction)&&(direction=null),{firstFieldIndex,lastFieldIndex,direction}}function isWordPlanBingo(wordPlan){return wordPlan.handIndices.filter(it=>it!=null).length===HAND_SIZE}function linePartsOptionsToRegExpStrings({lettersInHandRe,partsOptions,trim}){const result=[];for(const parts of partsOptions){let reString=trim?"":"^";for(const[index,part]of parts.option.entries()){if(part.gapBefore>0){const isFirstPart=index===0,isLastPartOfOnlyGap=index===parts.option.length-1&&!part.text;isFirstPart||isLastPartOfOnlyGap?trim||(reString+=`(${lettersInHandRe}{0,${part.gapBefore}})`):reString+=`(${lettersInHandRe}{${part.gapBefore}})`}part.text&&(reString+=`(${part.text})`)}reString+=trim?"":"$",reString?result.push(reString):result.push("a^")}return result}function wordPlanHash(wordPlan){return[wordPlan.fieldIndex,wordPlan.direction,wordPlan.word,...wordPlan.handIndices.map(it=>it==null?"-":it.toString())].join(":")}function wordPlanIncludesFieldIndex(wordPlan,fieldIndex,boardSize){const fieldIndexOffset=getFieldIndexOffset(wordPlan.direction,boardSize);for(let i=0;i<wordPlan.handIndices.length;i++)if(wordPlan.fieldIndex+i*fieldIndexOffset===fieldIndex)return!0;return!1}function disownTiles(board){for(const field of board)field.tile&&(field.tile.isOwned?(field.tile.isOwned=null,field.tile.isLast=!0):field.tile.isLast&&(field.tile.isLast=null))}function jsonClone(o){return JSON.parse(JSON.stringify(o))}function wordPlanToBoard(board,boardSize,hand,wordPlan){const boardDraft=jsonClone(board);disownTiles(boardDraft);const tiles=wordPlan.handIndices.map(handIndex=>handIndex==null?null:jsonClone(hand[handIndex]));for(let tileIndex=0;tileIndex<tiles.length;tileIndex++){const tile=jsonClone(tiles[tileIndex]);if(tile){const fieldIndex=wordPlan.fieldIndex+tileIndex*getFieldIndexOffset(wordPlan.direction,boardSize),field=boardDraft[fieldIndex];field.tile=tile,tile.isOwned=!0,tile.isJoker&&(tile.letter=wordPlan.jokerLetters[tileIndex])}}return boardDraft}function wordPlanToHand(hand,wordPlan){const result=jsonClone(hand);for(const index of wordPlan.handIndices)index!=null&&(result[index]=null);return result}function getPotentialStartingWords({words,board,boardSize,hand}){const startFieldIndex=findStartFieldIndex(board),startColIndex=getColumnIndex(startFieldIndex,boardSize),startRowIndex=getRowIndex(startFieldIndex,boardSize),lettersInHandRe=getLettersInHandRe(hand);if(!lettersInHandRe)return new Map;const wordPlans=new Map;for(const direction of[Direction.Horizontal,Direction.Vertical]){const partsOptions=[{fieldOffset:0,option:[{gapBefore:direction===Direction.Horizontal?boardSize.width:boardSize.height,fieldCount:0,text:""}]}],reStrings=linePartsOptionsToRegExpStrings({lettersInHandRe,partsOptions}),re=new RegExp(reStrings.join("|"));for(const word of words){if(!re.test(word))continue;const lineIndex=direction===Direction.Horizontal?startRowIndex:startColIndex,wordParts=[{gapBefore:0,text:word,fieldCount:direction===Direction.Horizontal?boardSize.width:boardSize.height}],placementInfos=getPlacementInfos({fieldOffset:0,wordParts,hand});for(const placementInfo of placementInfos){let bestScore=-1/0,bestWordPlan;for(let fieldOffset=0;fieldOffset<=placementInfo.fieldOffset;fieldOffset++){const wordPlan={direction,fieldIndex:getLineFieldIndex(boardSize,direction,lineIndex,fieldOffset),handIndices:placementInfo.handIndices,jokerLetters:placementInfo.jokerLetters,score:NaN,word,board:[],hand:[]};if(!wordPlanIncludesFieldIndex(wordPlan,startFieldIndex,boardSize))continue;wordPlan.board=wordPlanToBoard(board,boardSize,hand,wordPlan);const wordInfo=getWordInfo(wordPlan.board,boardSize),allOwnedWords=getAllOwnedWords(wordPlan.board,boardSize,wordInfo);wordPlan.score=getMoveScore(allOwnedWords,isWordPlanBingo(wordPlan)),wordPlan.score>bestScore&&(wordPlan.hand=wordPlanToHand(hand,wordPlan),bestScore=wordPlan.score,bestWordPlan=wordPlan)}bestWordPlan&&wordPlans.set(wordPlanHash(bestWordPlan),bestWordPlan)}}}return wordPlans}function getLine(board,boardSize,lineIndex,direction){return direction===Direction.Horizontal?getRowLine(board,boardSize,lineIndex):getColumnLine(board,boardSize,lineIndex)}function getLineParts(line){const parts=[];let wasGap=!1;for(const[index,field]of line.entries())if(field.tile){if(index===0)parts.push({gapBefore:0,text:field.tile.letter,fieldCount:1});else{const fixedLinePart=parts[parts.length-1];fixedLinePart.text+=field.tile.letter,fixedLinePart.fieldCount++}wasGap=!1}else wasGap?parts[parts.length-1].gapBefore++:parts.push({gapBefore:1,text:"",fieldCount:0}),wasGap=!0;return parts}function getWordSlices({word,res,resTrimmed,linePartsOptions}){const result=[];for(const[reIndex,re]of res.entries())if(re.test(word)){const reTrimmed=resTrimmed[reIndex],linePartsOption=linePartsOptions[reIndex];for(let reTrimmedStartIndex=0;reTrimmedStartIndex<word.length;){reTrimmed.lastIndex=reTrimmedStartIndex;const trimmedMatch=reTrimmed.exec(word);if(!trimmedMatch)break;const matchStartIndex=trimmedMatch.index,matchEndIndex=reTrimmed.lastIndex,wordPartStrings=trimmedMatch.slice(1,trimmedMatch.length),isFixedFirst=matchStartIndex===0;isFixedFirst||wordPartStrings.unshift("",word.slice(0,matchStartIndex)),matchEndIndex<word.length&&wordPartStrings.push(word.slice(matchEndIndex));const wordParts=[];let hasGap=!1;for(let stringIndex=0;stringIndex<wordPartStrings.length;stringIndex+=2){const handString=wordPartStrings[stringIndex+1]??"";if(handString&&(hasGap=!0),isFixedFirst){const fixedLinePart=linePartsOption.option[stringIndex/2],handLinePart=linePartsOption.option[stringIndex/2+1];wordParts.push({gapBefore:fixedLinePart.fieldCount,text:handString,fieldCount:handLinePart?.gapBefore??0})}else{const fixedLinePart=linePartsOption.option[(stringIndex-2)/2],handLinePart=linePartsOption.option[(stringIndex-2)/2+1];wordParts.push({gapBefore:fixedLinePart?.fieldCount??0,text:handString,fieldCount:handLinePart?.gapBefore??0})}}hasGap&&result.push({word,wordParts,fieldOffset:isFixedFirst?linePartsOption.fieldOffset+linePartsOption.option[0].gapBefore:linePartsOption.fieldOffset}),reTrimmedStartIndex=matchStartIndex+1}}return result}function getWordString(word){return word.map(_=>_.tile.letter).join("")}function linePartsToLinePartsOptions(parts){const result=[];let fieldOffset=0;for(let i=0;i<parts.length;i++){for(let j=i;j<parts.length;j++){const partsOption=parts.slice(i,j+1);i>0&&(partsOption[0]={...partsOption[0],gapBefore:Math.max(0,partsOption[0].gapBefore-1)}),partsOption.find(part=>part.gapBefore>0)&&partsOption.find(part=>part.text)&&result.push({option:partsOption,fieldOffset:i>0?fieldOffset+1:fieldOffset});const partsOptionShort=partsOption.slice(),end=partsOptionShort.length-1;partsOptionShort.length>1&&partsOptionShort[end].text&&partsOptionShort[end].gapBefore>1&&(partsOptionShort[end]={gapBefore:Math.max(0,partsOptionShort[end].gapBefore-1),text:"",fieldCount:0},partsOptionShort.find(part=>part.gapBefore>0)&&partsOptionShort.find(part=>part.text)&&result.push({option:partsOptionShort,fieldOffset:i>0?fieldOffset+1:fieldOffset}))}fieldOffset+=parts[i].gapBefore+parts[i].fieldCount}return result}function wordSliceToWordPlans({wordSlice,boardSize,hand:originalHand,lineIndex,direction}){const wordPlans=[],hand=originalHand.slice(),placementInfos=getPlacementInfos({fieldOffset:wordSlice.fieldOffset,wordParts:wordSlice.wordParts,hand});for(const placementInfo of placementInfos)wordPlans.push({word:wordSlice.word,fieldIndex:getLineFieldIndex(boardSize,direction,lineIndex,placementInfo.fieldOffset),direction,handIndices:placementInfo.handIndices,jokerLetters:placementInfo.jokerLetters,score:NaN,board:[],hand:[]});return wordPlans}function getPotentialWordsInLine({words,board,boardSize,lineIndex,direction,hand,pinnedFieldIndex}){const line=getLine(board,boardSize,lineIndex,direction);if(!line.find(field=>!!field.tile))return new Map;const lettersInHandRe=getLettersInHandRe(hand);if(!lettersInHandRe)return new Map;const lineParts=getLineParts(line),linePartsOptions=linePartsToLinePartsOptions(lineParts),reStrings=linePartsOptionsToRegExpStrings({lettersInHandRe,partsOptions:linePartsOptions}),re=new RegExp(reStrings.join("|")),res=reStrings.map(s=>new RegExp(s)),resTrimmed=linePartsOptionsToRegExpStrings({lettersInHandRe,partsOptions:linePartsOptions,trim:!0}).map(s=>new RegExp(s,"g")),wordPlans=new Map;for(const word of words){if(!re.test(word))continue;const wordSlices=getWordSlices({word,res,resTrimmed,linePartsOptions});for(const wordSlice of wordSlices){const newWordPlans=wordSliceToWordPlans({lineIndex,direction,wordSlice,hand,boardSize});wordPlansLoop:for(const wordPlan of newWordPlans){if(pinnedFieldIndex!=null&&!wordPlanIncludesFieldIndex(wordPlan,pinnedFieldIndex,boardSize))continue;const hash=wordPlanHash(wordPlan);if(wordPlans.has(hash))continue;wordPlan.board=wordPlanToBoard(board,boardSize,hand,wordPlan);const wordInfo=getWordInfo(wordPlan.board,boardSize),allOwnedWords=getAllOwnedWords(wordPlan.board,boardSize,wordInfo);for(const word2 of allOwnedWords)if(word2.length>1&&!words.includes(getWordString(word2)))continue wordPlansLoop;wordPlan.score=getMoveScore(allOwnedWords,isWordPlanBingo(wordPlan)),wordPlan.hand=wordPlanToHand(hand,wordPlan),wordPlans.set(hash,wordPlan)}}}return wordPlans}function replaceHandIndexInWordPlan(wordPlan,fieldIndex,handIndex,boardSize){const fieldIndexOffset=getFieldIndexOffset(wordPlan.direction,boardSize);for(let i=0;i<wordPlan.handIndices.length;i++)if(wordPlan.fieldIndex+i*fieldIndexOffset===fieldIndex){wordPlan.handIndices[i]=handIndex;break}}function getPotentialWords(options){const{board,boardSize,words,hand}=options,wordPlansMap=new Map;if(boardIsEmpty(board)){const wordPlans=getPotentialStartingWords({words,board,boardSize,hand});for(const[hash,wordPlan]of wordPlans)wordPlansMap.set(hash,wordPlan)}else{for(const direction of[Direction.Horizontal,Direction.Vertical])for(let lineIndex=0;lineIndex<(direction===Direction.Horizontal?boardSize.height:boardSize.width);lineIndex++){const wordPlans=getPotentialWordsInLine({...options,direction,lineIndex});for(const[hash,wordPlan]of wordPlans)wordPlansMap.set(hash,wordPlan)}for(const wordPlan of wordPlansMap.values()){const tilesToPlace=wordPlan.handIndices.filter(tile=>tile!=null);if(tilesToPlace.length===1){const placedTileFieldIndex=wordPlan.board.findIndex(field=>field.tile?.isOwned),crossDirection=theOtherDirection(wordPlan.direction),crossDirectionOffset=getFieldIndexOffset(crossDirection,boardSize);if(board[placedTileFieldIndex-crossDirectionOffset]?.tile==null&&board[placedTileFieldIndex+crossDirectionOffset]?.tile==null){const newPlans=getPotentialWordsInLine({words,board:wordPlan.board,lineIndex:getLineIndex(placedTileFieldIndex,boardSize,crossDirection),boardSize,direction:crossDirection,hand:wordPlan.hand,pinnedFieldIndex:placedTileFieldIndex});for(const newPlan of newPlans.values()){replaceHandIndexInWordPlan(newPlan,placedTileFieldIndex,tilesToPlace[0],boardSize);const hash=wordPlanHash(newPlan);if(wordPlansMap.has(hash))continue;newPlan.hand=wordPlanToHand(hand,newPlan),newPlan.board=wordPlanToBoard(board,boardSize,hand,newPlan);const wordInfo=getWordInfo(newPlan.board,boardSize),allOwnedWords=getAllOwnedWords(newPlan.board,boardSize,wordInfo);newPlan.score=getMoveScore(allOwnedWords,isWordPlanBingo(newPlan)),wordPlansMap.set(hash,newPlan)}}}}}return Array.from(wordPlansMap.values()).sort((a,b)=>a.direction-b.direction||a.fieldIndex-b.fieldIndex||a.handIndices.length-b.handIndices.length)}self.addEventListener("unhandledrejection",event=>{throw event.reason}),self.onmessage=async event=>{const{board,boardSize,hand,words}=event.data,wordPlans=getPotentialWords({words,board,boardSize,hand}),result={horizontal:wordPlans.filter(wordPlan=>wordPlan.direction===Direction.Horizontal),vertical:wordPlans.filter(wordPlan=>wordPlan.direction===Direction.Vertical)};self.postMessage(result)}})();
