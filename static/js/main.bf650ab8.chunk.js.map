{"version":3,"sources":["model/LocalStorageKey.tsx","action/actions.tsx","model/Mode.tsx","select/simpleSelectors.tsx","action/saveGameThunk.tsx","action/nextPlayerAndSaveThunk.tsx","action/newGameThunk.tsx","model/Constants.tsx","fun/getHandTileCount.tsx","select/selectHand.tsx","select/selectHandCount.tsx","select/selectIsBingo.tsx","comp/BagComp.tsx","select/selectField.tsx","model/FieldKind.tsx","select/selectHandTile.tsx","comp/AspectComp.tsx","comp/TileComp.tsx","comp/BoardComp.tsx","model/MoveError.tsx","action/selectFieldThunk.tsx","fun/getWordString.tsx","model/Direction.tsx","fun/isWordStringValid.tsx","fun/getNextFieldIndex.tsx","fun/getColumnIndex.tsx","fun/getColumnLine.tsx","fun/getRowIndex.tsx","fun/getRowLine.tsx","fun/getWordFromLine.tsx","fun/getWordAt.tsx","fun/theOtherDirection.tsx","select/selectWordInfo.tsx","fun/isThereAGap.tsx","select/selectAllOwnedWords.tsx","fun/getAllOwnedWords.tsx","select/selectMoveErrors.tsx","comp/ErrorsComp.tsx","select/selectWinners.tsx","select/selectIsGameDrawn.tsx","select/selectWinnersNames.tsx","comp/PlayersComp.tsx","fun/numberToSignedString.tsx","comp/GameEndedComp.tsx","model/AddWordContext.tsx","comp/HandComp.tsx","action/selectHandThunk.tsx","select/selectOwnValidAndInvalidWords.tsx","fun/getWordScore.tsx","comp/WordListComp.tsx","action/addWordRequestThunk.tsx","comp/OwnWordInfoComp.tsx","select/selectPlacedValidAndInvalidWords.tsx","comp/PlacedWordInfoComp.tsx","select/selectMoveScore.tsx","fun/getHandValue.tsx","select/selectEmptyHandBonus.tsx","select/selectPlayerBonuses.tsx","action/endGameThunk.tsx","fun/getLettersInHand.tsx","fun/getLettersInHandSet.tsx","fun/partsToRegExpString.tsx","fun/linePartsToRegExpStrings.tsx","fun/add.tsx","fun/findLetterIndexInHand.tsx","fun/getHandIndicesForWord.tsx","fun/wordSliceAndLinePartsToWordPlan.tsx","fun/wordSliceAndLinePartsToWordPlanInternal.tsx","fun/getPotentialWordsInLine.tsx","fun/getLine.tsx","fun/getLettersInHandRe.tsx","fun/getLineParts.tsx","fun/getWordSlices.tsx","fun/wordPlanToBoard.tsx","fun/getPotentialWords.tsx","comp/PlaceTileButtonsComp.tsx","action/doneThunk.tsx","action/skipThunk.tsx","comp/ReplaceTilesButtonsComp.tsx","comp/AppComp.tsx","fun/savedGameExists.tsx","action/loadGameThunk.tsx","model/AppState.tsx","model/Board.tsx","model/Bag.tsx","model/Hands.tsx","model/Player.tsx","model/HandIndicesToReplace.tsx","serviceWorker.ts","index.tsx"],"names":["LocalStorageKey","Mode","setGame","createAction","collectTiles","disownTiles","fillHand","nextPlayer","resetGame","score","setSelectedField","selectHand","setJokerLetter","setMode","setPlayerName","swapHandAndBoard","swapHands","swapTiles","toggleHandIndexToReplace","removeTilesToReplaceFromHand","deselectTilesToReplace","addTilesToBag","incrementSkipCount","resetSkipCount","scoreBonuses","type","a","payload","selectBoard","state","board","selectBag","bag","selectHands","hands","selectMode","mode","selectHandIndicesToReplace","handIndicesToReplace","selectPlayers","players","selectHandIndex","handIndex","selectFieldIndex","fieldIndex","saveGameThunk","dispatch","getState","localStorage","SavedGame","JSON","stringify","e","console","error","nextPlayerAndSaveThunk","newGameThunk","names","map","player","name","forEach","playerIndex","PlaceTile","BOARD_SIZE","CENTER_FIELD_INDEX","getHandTileCount","hand","reduce","sum","tile","isUndefinedOrNull","createSelector","selectHandCount","selectIsBingo","startingHandCount","handCount","BagComp","_ref","react","className","concat","length","FieldKind","selectField","selectHandTile","AspectComp","width","height","children","viewBox","TileComp","neverOwned","AspectComp_AspectComp","isOwned","isJoker","isLast","filter","Boolean","join","letter","MoveError","BoardComp","connect","field","aFieldIndex","key","fieldKindToCssClass","kind","onClick","fieldIndexToSelect","selectedFieldIndex","handTile","selectedField","fieldToSelect","fieldIndexA","fieldIndexB","TileComp_TileComp","k","Normal","DoubleLetter","DoubleWord","Start","TripleLetter","TripleWord","Error","fieldKindToLabel","getWordString","word","_","Direction","isWordStringValid","w","words","indexOf","getFieldIndexOffset","direction","Horizontal","getColumnIndex","getColumnLine","columnIndex","column","rowIndex","push","getRowIndex","Math","floor","getRowLine","lineIndex","firstFieldIndex","slice","getWordFromLine","line","index","startLineIndex","endLineIndex","unshift","getWordAt","theOtherDirection","d","Vertical","selectWordInfo","lastFieldIndex","colIndex","newColIndex","newRowIndex","horizontal","vertical","min","max","startFieldIndex","endFieldIndex","isThereAGap","selectAllOwnedWords","selectMoveErrors","errors","Set","add","NoTile","size","OneTile","NoDirection","touchesStart","touchesUnowned","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","InvalidWord","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","err","return","NoStart","NoConnection","Array","from","ErrorsComp","selectWinners","Ended","winningScore","winners","selectIsGameDrawn","selectWinnersNames","winnerNames","winner","last","rest","PlayersComp","playerBonuses","isEnabled","aPlayerIndex","prompt","trim","n","GameEndedComp","isGameDrawn","winnerName","PlayersComp_PlayersComp","AddWordContext","HandComp","isNullOrUndefined","aHandIndex","handIndexToSelect","_getState","ReplaceTiles","handIndexA","handIndexB","selectOwnValidAndInvalidWords","valid","invalid","getWordScore","wordMulti","tileScore","WordListComp","showScore","wordClassName","scoreClassName","addWordContext","label","wordString","href","encodeURIComponent","target","rel","replace","context","window","confirm","Request","fetch","method","headers","Content-Type","body","then","response","json","alert","result","catch","OwnWordInfoComp","Flag","selectPlacedValidAndInvalidWords","PlacedWordInfoComp","selectMoveScore","isBingo","getHandValue","memoizee","selectEmptyHandBonus","selectPlayerBonuses","emptyHandBonus","isNull","endGameThunk","getLettersInHand","lettersInHandSet","letters","delete","getLettersInHandSet","sort","b","partsToRegExpString","lettersInHandRe","parts","arguments","reString","part","isNumber","text","linePartsToRegExpStrings","startIndex","endIndex","subParts","end","findLetterIndexInHand","NaN","entries","_ref6","_ref2","Object","slicedToArray","isNaN","_ref5","_ref4","getHandIndicesForWord","originalHand","i","wordPart","lettersInHand","letterInHand","startsWith","letterIndex","wordSliceAndLinePartsToWordPlan","_ref$wordSlice","wordSlice","firstIsFixed","wordParts","lineParts","firstFixedPart","wordPlans","lineTileIndices","linePartStartIndex","_ref3","linePartIndex","linePart","fieldCount","wordPlan","lineTileIndex","hasMissingParts","wordPartsEnd","tiles","handIndicesForWord","test","apply","toConsumableArray","wordSliceAndLinePartsToWordPlanInternal","getPotentialWordsInLine","getLine","find","getLettersInHandRe","wasGap","lastGapStartIndex","withInterface","fixedLinePart","getLineParts","reStrings","reStringsTrimmed","re","RegExp","res","s","resTrimmed","wordSlices","reTrimmed","lastIndex","r","exec","matchStartIndex","matchEndIndex","getWordSlices","newWordPlans","arr","boardPlan","boardDraft","parse","tileIndex","wordPlanToBoard","getPotentialWords","options","objectSpread","PlaceTileButtonsComp","moveScore","moveErrors","disabled","skipCount","get","onChange","ReplaceTilesButtonsComp","tilesToReplace","AppComp","BoardComp_BoardComp","NotStarted","savedGame","game","app","BagComp_BagComp","HandComp_HandComp","OwnWordInfoComp_OwnWordInfoComp","ErrorsComp_ErrorsComp","PlaceTileButtonsComp_PlaceTileButtonsComp","PlacedWordInfoComp_PlacedWordInfoComp","createAppState","split","flatMap","row","count","range","appStateReducer","produce","action","shift","splice","random","newHand","_action$payload","_action$payload2","tileOnBoard","tileInHand","_action$payload3","tileA","tileB","_action$payload4","fieldATile","fieldBTile","fill","_state$bag","isLocalhost","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","log","onUpdate","onSuccess","__webpack_require__","__webpack_exports__","store","configureStore","reducer","ReactDOM","render","react_default","createElement","es","AppComp_AppComp","document","getElementById","URL","process","origin","addEventListener","contentType","status","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.bf650ab8.chunk.js","sourcesContent":["export enum LocalStorageKey {\n\tSavedGame = 'game',\n}\n","import { IAppState } from '../model/AppState'\nimport { Mode } from '../model/Mode'\nimport { ITile } from '../model/Tile'\n\nexport const setGame = createAction<'setGame', { game: IAppState }>('setGame')\nexport const collectTiles = createAction<'collectTiles'>('collectTiles')\nexport const disownTiles = createAction<'disownTiles'>('disownTiles')\nexport const fillHand = createAction<'fillHand'>('fillHand')\nexport const nextPlayer = createAction<'nextPlayer'>('nextPlayer')\nexport const resetGame = createAction<'resetGame'>('resetGame')\nexport const score = createAction<'score', number>('score')\nexport const setSelectedField = createAction<\n\t'setSelectedField',\n\t{ fieldIndex: number | null }\n>('setSelectedField')\nexport const selectHand = createAction<\n\t'selectHand',\n\t{ handIndex: number | null }\n>('selectHand')\nexport const setJokerLetter = createAction<\n\t'setJokerLetter',\n\t{ letter: string }\n>('setJokerLetter')\nexport const setMode = createAction<'setMode', Mode>('setMode')\nexport const setPlayerName = createAction<\n\t'setPlayerName',\n\t{\n\t\tplayerIndex: number\n\t\tname: string\n\t}\n>('setPlayerName')\nexport const swapHandAndBoard = createAction<\n\t'swapHandAndBoard',\n\t{\n\t\tfieldIndex: number\n\t\thandIndex: number\n\t}\n>('swapHandAndBoard')\nexport const swapHands = createAction<\n\t'swapHands',\n\t{\n\t\thandIndexA: number\n\t\thandIndexB: number\n\t}\n>('swapHands')\nexport const swapTiles = createAction<\n\t'swapTiles',\n\t{\n\t\tfieldIndexA: number\n\t\tfieldIndexB: number\n\t}\n>('swapTiles')\nexport const toggleHandIndexToReplace = createAction<\n\t'toggleHandIndexToReplace',\n\t{\n\t\thandIndex: number\n\t}\n>('toggleHandIndexToReplace')\nexport const removeTilesToReplaceFromHand = createAction<\n\t'removeTilesToReplaceFromHand'\n>('removeTilesToReplaceFromHand')\nexport const deselectTilesToReplace = createAction<'deselectTilesToReplace'>(\n\t'deselectTilesToReplace',\n)\nexport const addTilesToBag = createAction<'addTilesToBag', { tiles: ITile[] }>(\n\t'addTilesToBag',\n)\nexport const incrementSkipCount = createAction<'incrementSkipCount'>(\n\t'incrementSkipCount',\n)\nexport const resetSkipCount = createAction<'resetSkipCount'>('resetSkipCount')\nexport const scoreBonuses = createAction<'scoreBonuses', ReadonlyArray<number>>(\n\t'scoreBonuses',\n)\n\nfunction createAction<T extends string, P = void>(type: T) {\n\tconst a = (payload: P) => ({ type, payload })\n\ta.type = type\n\treturn a\n}\n","export enum Mode {\n\tNotStarted = 'NotStarted',\n\tPlaceTile = 'PlaceTile',\n\tReplaceTiles = 'ReplaceTiles',\n\tEnded = 'Ended',\n}\n","import { IAppState } from '../model/AppState'\nimport { TBag } from '../model/Bag'\nimport { TBoard } from '../model/Board'\nimport { THandIndicesToReplace } from '../model/HandIndicesToReplace'\nimport { THands } from '../model/Hands'\nimport { Mode } from '../model/Mode'\n\nexport const selectBoard = (state: IAppState): TBoard => state.board\nexport const selectBag = (state: IAppState): TBag => state.bag\nexport const selectHands = (state: IAppState): THands => state.hands\nexport const selectMode = (state: IAppState): Mode => state.mode\nexport const selectHandIndicesToReplace = (\n\tstate: IAppState,\n): THandIndicesToReplace => state.handIndicesToReplace\nexport const selectPlayers = (state: IAppState) => state.players\nexport const selectPlayerIndex = (state: IAppState) => state.playerIndex\nexport const selectHandIndex = (state: IAppState) => state.handIndex\nexport const selectFieldIndex = (state: IAppState) => state.fieldIndex\nexport const selectStartingHandCount = (state: IAppState) =>\n\tstate.startingHandCount\n","import { LocalStorageKey } from '../model/LocalStorageKey'\nimport { ThunkValue } from './ThunkValue'\n\nexport function saveGameThunk(): ThunkValue {\n\treturn (dispatch, getState) => {\n\t\ttry {\n\t\t\tlocalStorage[LocalStorageKey.SavedGame] = JSON.stringify(getState())\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t}\n\t}\n}\n","import { nextPlayer } from './actions'\nimport { saveGameThunk } from './saveGameThunk'\nimport { ThunkValue } from './ThunkValue'\n\nexport function nextPlayerAndSaveThunk(): ThunkValue {\n\treturn (dispatch, getState) => {\n\t\tdispatch(nextPlayer())\n\t\tdispatch(saveGameThunk())\n\t}\n}\n","import { Mode } from '../model/Mode'\nimport { selectPlayers } from '../select/simpleSelectors'\nimport {\n\tfillHand,\n\tnextPlayer,\n\tresetGame,\n\tsetMode,\n\tsetPlayerName,\n} from './actions'\nimport { nextPlayerAndSaveThunk } from './nextPlayerAndSaveThunk'\nimport { ThunkValue } from './ThunkValue'\n\nexport function newGameThunk(): ThunkValue {\n\treturn (dispatch, getState) => {\n\t\tconst state = getState()\n\t\tconst players = selectPlayers(state)\n\t\tconst names = players.map(player => player.name)\n\t\tdispatch(resetGame())\n\t\tnames.forEach((name, playerIndex) => {\n\t\t\tdispatch(\n\t\t\t\tsetPlayerName({\n\t\t\t\t\tplayerIndex,\n\t\t\t\t\tname,\n\t\t\t\t}),\n\t\t\t)\n\t\t})\n\t\tdispatch(nextPlayer())\n\t\tdispatch(fillHand())\n\t\tdispatch(nextPlayer())\n\t\tdispatch(fillHand())\n\t\tdispatch(setMode(Mode.PlaceTile))\n\t\tdispatch(nextPlayerAndSaveThunk())\n\t}\n}\n","export const BOARD_SIZE = 15\nexport const CENTER_FIELD_INDEX = BOARD_SIZE * 7 + 7\nexport const BINGO_SCORE = 50\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { THand } from '../model/Hands'\n\nexport function getHandTileCount(hand: THand | null) {\n\treturn (hand || []).reduce(\n\t\t(sum, tile) => sum + (isUndefinedOrNull(tile) ? 0 : 1),\n\t\t0,\n\t)\n}\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { createSelector } from 'reselect'\nimport { selectHands, selectPlayerIndex } from './simpleSelectors'\n\nexport const selectHand = createSelector(\n\t[selectHands, selectPlayerIndex],\n\t(hands, playerIndex) => {\n\t\treturn isUndefinedOrNull(playerIndex) ? null : hands[playerIndex]\n\t},\n)\n","import { createSelector } from 'reselect'\nimport { getHandTileCount } from '../fun/getHandTileCount'\nimport { selectHand } from './selectHand'\n\nexport const selectHandCount = createSelector(\n\t[selectHand],\n\tgetHandTileCount,\n)\n","import { createSelector } from 'reselect'\nimport { selectHandCount } from './selectHandCount'\nimport { selectStartingHandCount } from './simpleSelectors'\n\nexport const selectIsBingo = createSelector(\n\t[selectStartingHandCount, selectHandCount],\n\t(startingHandCount, handCount) => {\n\t\treturn startingHandCount === 7 && handCount === 0\n\t},\n)\n","import * as React from 'react'\nimport { TBag } from '../model/Bag'\nimport './BagComp.css'\n\nexport function BagComp({ bag }: { bag: TBag }) {\n\treturn <div className='bag'>{`Lapkák a zsákban: ${bag.length}`}</div>\n}\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { createSelector } from 'reselect'\nimport { selectBoard, selectFieldIndex } from './simpleSelectors'\n\nexport const selectField = createSelector(\n\t[selectBoard, selectFieldIndex],\n\t(board, fieldIndex) => {\n\t\treturn isUndefinedOrNull(fieldIndex) ? null : board[fieldIndex]\n\t},\n)\n","export enum FieldKind {\n\tNormal = '-',\n\tStart = 's',\n\tDoubleLetter = 'l',\n\tTripleLetter = 'L',\n\tDoubleWord = 'w',\n\tTripleWord = 'W',\n}\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { createSelector } from 'reselect'\nimport { selectHand } from './selectHand'\nimport { selectHandIndex } from './simpleSelectors'\n\nexport const selectHandTile = createSelector(\n\t[selectHand, selectHandIndex],\n\t(hand, handIndex) => {\n\t\treturn hand && !isUndefinedOrNull(handIndex) ? hand[handIndex] : null\n\t},\n)\n","import * as React from 'react'\nimport './AspectComp.css'\n\nexport function AspectComp({\n\twidth,\n\theight,\n\tchildren,\n}: React.PropsWithChildren<{\n\twidth: number\n\theight: number\n}>) {\n\treturn (\n\t\t<div className='aspect'>\n\t\t\t<svg viewBox={`0 0 ${width} ${height}`} />\n\t\t\t{children}\n\t\t</div>\n\t)\n}\n","import * as React from 'react'\nimport { ITile } from '../model/Tile'\nimport { AspectComp } from './AspectComp'\nimport './TileComp.css'\n\nexport function TileComp({\n\ttile,\n\tneverOwned,\n}: {\n\ttile: ITile\n\tneverOwned?: boolean\n}) {\n\treturn (\n\t\t<AspectComp width={1} height={1}>\n\t\t\t<div\n\t\t\t\tclassName={[\n\t\t\t\t\t'tile',\n\t\t\t\t\t!neverOwned && tile.isOwned && 'is-owned',\n\t\t\t\t\ttile.isJoker && 'is-joker',\n\t\t\t\t\ttile.isLast && 'is-last',\n\t\t\t\t]\n\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t.join(' ')}\n\t\t\t>\n\t\t\t\t<div className='tile-letter'>{tile.letter}</div>\n\t\t\t\t<div className='tile-score'>{tile.score}</div>\n\t\t\t</div>\n\t\t</AspectComp>\n\t)\n}\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { selectFieldThunk } from '../action/selectFieldThunk'\nimport { IAppState } from '../model/AppState'\nimport { TBoard } from '../model/Board'\nimport { FieldKind } from '../model/FieldKind'\nimport { selectBoard } from '../select/simpleSelectors'\nimport { AspectComp } from './AspectComp'\nimport './BoardComp.css'\nimport { DispatchProp } from './DispatchProp'\nimport { TileComp } from './TileComp'\n\ninterface BoardCompPropsFromState {\n\tfieldIndex: number | null\n\tboard: TBoard\n}\nexport interface BoardCompProps extends BoardCompPropsFromState, DispatchProp {}\n\nexport const BoardComp = connect(\n\t(state: IAppState): BoardCompPropsFromState => ({\n\t\tboard: selectBoard(state),\n\t\tfieldIndex: state.fieldIndex,\n\t}),\n)(({ fieldIndex, board, dispatch }: BoardCompProps) => {\n\treturn (\n\t\t<div className='board'>\n\t\t\t{board.map((field, aFieldIndex) => (\n\t\t\t\t<AspectComp key={aFieldIndex} width={1} height={1}>\n\t\t\t\t\t<div\n\t\t\t\t\t\tclassName={[\n\t\t\t\t\t\t\t'board-field',\n\t\t\t\t\t\t\tfieldKindToCssClass(field.kind),\n\t\t\t\t\t\t\taFieldIndex === fieldIndex && 'is-selected',\n\t\t\t\t\t\t]\n\t\t\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t\t\t.join(' ')}\n\t\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\t\tdispatch(selectFieldThunk(aFieldIndex))\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t{field.tile ? (\n\t\t\t\t\t\t\t<TileComp tile={field.tile} />\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\tfieldKindToLabel(field.kind)\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t</AspectComp>\n\t\t\t))}\n\t\t</div>\n\t)\n})\n\nfunction fieldKindToCssClass(k: FieldKind): string {\n\tswitch (k) {\n\t\tcase FieldKind.Normal:\n\t\t\treturn 'is-normal'\n\t\tcase FieldKind.DoubleLetter:\n\t\t\treturn 'is-double-letter'\n\t\tcase FieldKind.DoubleWord:\n\t\t\treturn 'is-double-word'\n\t\tcase FieldKind.Start:\n\t\t\treturn 'is-start'\n\t\tcase FieldKind.TripleLetter:\n\t\t\treturn 'is-triple-letter'\n\t\tcase FieldKind.TripleWord:\n\t\t\treturn 'is-triple-word'\n\t\tdefault:\n\t\t\tthrow new Error(`[ppp03n]: ${k}`)\n\t}\n}\n\nfunction fieldKindToLabel(k: FieldKind): string {\n\tswitch (k) {\n\t\tcase FieldKind.Normal:\n\t\t\treturn ' '\n\t\tcase FieldKind.DoubleLetter:\n\t\t\treturn '2×\\nBetű'\n\t\tcase FieldKind.DoubleWord:\n\t\t\treturn '2×\\nSzó'\n\t\tcase FieldKind.Start:\n\t\t\treturn 'Start'\n\t\tcase FieldKind.TripleLetter:\n\t\t\treturn '3×\\nBetű'\n\t\tcase FieldKind.TripleWord:\n\t\t\treturn '3×\\nSzó'\n\t\tdefault:\n\t\t\tthrow new Error(`[ppp079]: ${k}`)\n\t}\n}\n","export enum MoveError {\n\tNoTile,\n\tOneTile,\n\tNoDirection,\n\tNoStart,\n\tNoConnection,\n\tInvalidWord,\n}\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { Mode } from '../model/Mode'\nimport { selectField } from '../select/selectField'\nimport { selectHandTile } from '../select/selectHandTile'\nimport {\n\tselectBoard,\n\tselectFieldIndex,\n\tselectHandIndex,\n\tselectMode,\n} from '../select/simpleSelectors'\nimport { setSelectedField, swapHandAndBoard, swapTiles } from './actions'\nimport { ThunkValue } from './ThunkValue'\n\nexport function selectFieldThunk(fieldIndexToSelect: number): ThunkValue {\n\treturn (dispatch, getState) => {\n\t\tconst state = getState()\n\t\tconst { fieldIndex: selectedFieldIndex } = state\n\t\tconst mode = selectMode(state)\n\t\tif (mode !== Mode.PlaceTile) return\n\t\tconst handTile = selectHandTile(state)\n\t\tconst selectedField = selectField(state)\n\t\tconst fieldToSelect = selectBoard(state)[fieldIndexToSelect]\n\t\tif (\n\t\t\t!isUndefinedOrNull(selectedField) &&\n\t\t\t(selectedField.tile &&\n\t\t\t\tselectedField.tile.isOwned &&\n\t\t\t\t(!fieldToSelect.tile || fieldToSelect.tile.isOwned))\n\t\t) {\n\t\t\tdispatch(\n\t\t\t\tswapTiles({\n\t\t\t\t\tfieldIndexA: selectFieldIndex(state)!,\n\t\t\t\t\tfieldIndexB: fieldIndexToSelect,\n\t\t\t\t}),\n\t\t\t)\n\t\t} else if (\n\t\t\thandTile &&\n\t\t\t(!fieldToSelect.tile || fieldToSelect.tile.isOwned)\n\t\t) {\n\t\t\tdispatch(\n\t\t\t\tswapHandAndBoard({\n\t\t\t\t\thandIndex: selectHandIndex(state)!,\n\t\t\t\t\tfieldIndex: fieldIndexToSelect,\n\t\t\t\t}),\n\t\t\t)\n\t\t} else if (selectedFieldIndex === fieldIndexToSelect) {\n\t\t\tdispatch(\n\t\t\t\tsetSelectedField({\n\t\t\t\t\tfieldIndex: null,\n\t\t\t\t}),\n\t\t\t)\n\t\t} else {\n\t\t\tdispatch(\n\t\t\t\tsetSelectedField({\n\t\t\t\t\tfieldIndex: fieldIndexToSelect,\n\t\t\t\t}),\n\t\t\t)\n\t\t}\n\t}\n}\n","import { IField } from '../model/Field'\n\nexport function getWordString(word: ReadonlyArray<IField>): string {\n\treturn word.map(_ => _.tile!.letter).join('')\n}\n","export enum Direction {\n\tHorizontal,\n\tVertical,\n}\n","import words from '../res/words.json'\n\nexport function isWordStringValid(w: string): boolean {\n\treturn words.indexOf(w) >= 0\n}\n","import { BOARD_SIZE } from '../model/Constants'\nimport { Direction } from '../model/Direction'\n\nexport function getFieldIndexOffset(direction: Direction) {\n\treturn direction === Direction.Horizontal ? 1 : BOARD_SIZE\n}\n","import { BOARD_SIZE } from '../model/Constants'\n\nexport function getColumnIndex(fieldIndex: number) {\n\treturn fieldIndex % BOARD_SIZE\n}\n","import { BOARD_SIZE } from '../model/Constants'\nimport { IField } from '../model/Field'\nimport { getColumnIndex } from './getColumnIndex'\n\nexport function getColumnLine(\n\tboard: ReadonlyArray<IField>,\n\tfieldIndex: number,\n): IField[] {\n\tconst columnIndex = getColumnIndex(fieldIndex)\n\tconst column: IField[] = []\n\tfor (let rowIndex = 0; rowIndex < BOARD_SIZE; rowIndex++) {\n\t\tcolumn.push(board[rowIndex * BOARD_SIZE + columnIndex])\n\t}\n\treturn column\n}\n","import { BOARD_SIZE } from '../model/Constants'\n\nexport function getRowIndex(fieldIndex: number) {\n\treturn Math.floor(fieldIndex / BOARD_SIZE)\n}\n","import { BOARD_SIZE } from '../model/Constants'\nimport { IField } from '../model/Field'\n\nexport function getRowLine(\n\tboard: ReadonlyArray<IField>,\n\tlineIndex: number,\n): IField[] {\n\tconst firstFieldIndex = lineIndex * BOARD_SIZE\n\treturn board.slice(firstFieldIndex, firstFieldIndex + BOARD_SIZE)\n}\n","import { BOARD_SIZE } from '../model/Constants'\nimport { IField } from '../model/Field'\n\nexport function getWordFromLine(\n\tline: ReadonlyArray<IField>,\n\tlineIndex: number,\n) {\n\tconst word: IField[] = []\n\tlet index = lineIndex\n\tlet startLineIndex = lineIndex\n\tlet endLineIndex = lineIndex\n\twhile (index >= 0) {\n\t\tconst field = line[index]\n\t\tif (!field.tile) break\n\t\tword.unshift(field)\n\t\tstartLineIndex = index\n\t\tindex--\n\t}\n\tindex = lineIndex + 1\n\twhile (index < BOARD_SIZE) {\n\t\tconst field = line[index]\n\t\tif (!field || !field.tile) break\n\t\tword.push(field)\n\t\tendLineIndex = index\n\t\tindex++\n\t}\n\treturn {\n\t\tword: word.length > 1 ? word : [],\n\t\tstartLineIndex,\n\t\tendLineIndex,\n\t}\n}\n","import { Direction } from '../model/Direction'\nimport { IField } from '../model/Field'\nimport { getColumnIndex } from './getColumnIndex'\nimport { getColumnLine } from './getColumnLine'\nimport { getRowIndex } from './getRowIndex'\nimport { getRowLine } from './getRowLine'\nimport { getWordFromLine } from './getWordFromLine'\n\nexport function getWordAt(\n\tboard: ReadonlyArray<IField>,\n\tfieldIndex: number,\n\tdirection: Direction,\n) {\n\treturn direction === Direction.Horizontal\n\t\t? getWordFromLine(\n\t\t\t\tgetRowLine(board, getRowIndex(fieldIndex)),\n\t\t\t\tgetColumnIndex(fieldIndex),\n\t\t  )\n\t\t: getWordFromLine(\n\t\t\t\tgetColumnLine(board, getColumnIndex(fieldIndex)),\n\t\t\t\tgetRowIndex(fieldIndex),\n\t\t  )\n}\n","import { Direction } from '../model/Direction'\n\nexport function theOtherDirection(d: Direction) {\n\treturn d === Direction.Horizontal\n\t\t? Direction.Vertical\n\t\t: Direction.Horizontal\n}\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { createSelector } from 'reselect'\nimport { getColumnIndex } from '../fun/getColumnIndex'\nimport { getRowIndex } from '../fun/getRowIndex'\nimport { getWordAt } from '../fun/getWordAt'\nimport { isThereAGap } from '../fun/isThereAGap'\nimport { BOARD_SIZE } from '../model/Constants'\nimport { Direction } from '../model/Direction'\nimport { IWordInfo } from '../model/IWordInfo'\nimport { selectBoard } from './simpleSelectors'\n\nexport const selectWordInfo = createSelector(\n\t[selectBoard],\n\t(board): IWordInfo => {\n\t\tlet firstFieldIndex: number | null = null\n\t\tlet lastFieldIndex: number | null = null\n\t\tlet colIndex: number | null = null\n\t\tlet rowIndex: number | null = null\n\t\tlet direction: Direction | null = null\n\n\t\tfor (let fieldIndex = 0; fieldIndex < board.length; fieldIndex++) {\n\t\t\tconst field = board[fieldIndex]\n\t\t\tif (field.tile && field.tile.isOwned) {\n\t\t\t\tif (isUndefinedOrNull(colIndex)) {\n\t\t\t\t\t// First field\n\t\t\t\t\tfirstFieldIndex = fieldIndex\n\t\t\t\t\tlastFieldIndex = fieldIndex\n\t\t\t\t\tcolIndex = getColumnIndex(fieldIndex)\n\t\t\t\t\trowIndex = getRowIndex(fieldIndex)\n\t\t\t\t} else {\n\t\t\t\t\tconst newColIndex = getColumnIndex(fieldIndex)\n\t\t\t\t\tconst newRowIndex = getRowIndex(fieldIndex)\n\t\t\t\t\tif (lastFieldIndex === firstFieldIndex) {\n\t\t\t\t\t\t// Second field\n\t\t\t\t\t\tif (colIndex === newColIndex) {\n\t\t\t\t\t\t\tdirection = Direction.Vertical\n\t\t\t\t\t\t} else if (rowIndex === newRowIndex) {\n\t\t\t\t\t\t\tdirection = Direction.Horizontal\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Third+ field\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(direction === Direction.Vertical &&\n\t\t\t\t\t\t\t\tcolIndex !== newColIndex) ||\n\t\t\t\t\t\t\t(direction === Direction.Horizontal &&\n\t\t\t\t\t\t\t\trowIndex !== newRowIndex)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tdirection = null\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcolIndex = newColIndex\n\t\t\t\t\trowIndex = newRowIndex\n\t\t\t\t\tlastFieldIndex = fieldIndex\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!isUndefinedOrNull(firstFieldIndex)) {\n\t\t\tconst horizontal = getWordAt(\n\t\t\t\tboard,\n\t\t\t\tfirstFieldIndex,\n\t\t\t\tDirection.Horizontal,\n\t\t\t)\n\t\t\tconst vertical = getWordAt(\n\t\t\t\tboard,\n\t\t\t\tfirstFieldIndex,\n\t\t\t\tDirection.Vertical,\n\t\t\t)\n\t\t\tif (firstFieldIndex === lastFieldIndex) {\n\t\t\t\tif (horizontal.word.length) {\n\t\t\t\t\tdirection = Direction.Horizontal\n\t\t\t\t} else if (vertical.word.length) {\n\t\t\t\t\tdirection = Direction.Vertical\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (direction === Direction.Horizontal) {\n\t\t\t\tfirstFieldIndex = Math.min(\n\t\t\t\t\tfirstFieldIndex,\n\t\t\t\t\tgetRowIndex(firstFieldIndex) * BOARD_SIZE +\n\t\t\t\t\t\thorizontal.startLineIndex,\n\t\t\t\t)\n\t\t\t\tlastFieldIndex = Math.max(\n\t\t\t\t\tlastFieldIndex!,\n\t\t\t\t\tgetRowIndex(firstFieldIndex) * BOARD_SIZE +\n\t\t\t\t\t\thorizontal.endLineIndex,\n\t\t\t\t)\n\t\t\t} else if (direction === Direction.Vertical) {\n\t\t\t\tfirstFieldIndex = Math.min(\n\t\t\t\t\tfirstFieldIndex,\n\t\t\t\t\tvertical.startLineIndex * BOARD_SIZE +\n\t\t\t\t\t\tgetColumnIndex(firstFieldIndex),\n\t\t\t\t)\n\t\t\t\tlastFieldIndex = Math.max(\n\t\t\t\t\tlastFieldIndex!,\n\t\t\t\t\tvertical.endLineIndex * BOARD_SIZE +\n\t\t\t\t\t\tgetColumnIndex(firstFieldIndex),\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\t!isUndefinedOrNull(firstFieldIndex) &&\n\t\t\t!isUndefinedOrNull(lastFieldIndex) &&\n\t\t\t!isUndefinedOrNull(direction) &&\n\t\t\tisThereAGap(board, firstFieldIndex, lastFieldIndex, direction)\n\t\t) {\n\t\t\tdirection = null\n\t\t}\n\t\treturn {\n\t\t\tfirstFieldIndex,\n\t\t\tlastFieldIndex,\n\t\t\tdirection,\n\t\t}\n\t},\n)\n","import { Direction } from '../model/Direction'\nimport { IField } from '../model/Field'\nimport { getFieldIndexOffset } from './getNextFieldIndex'\n\nexport function isThereAGap(\n\tboard: ReadonlyArray<IField>,\n\tstartFieldIndex: number,\n\tendFieldIndex: number,\n\tdirection: Direction,\n) {\n\tfor (\n\t\tlet fieldIndex = startFieldIndex;\n\t\tfieldIndex <= endFieldIndex;\n\t\tfieldIndex += getFieldIndexOffset(direction)\n\t) {\n\t\tif (!board[fieldIndex].tile) return true\n\t}\n\treturn false\n}\n","import { createSelector } from 'reselect'\nimport { getAllOwnedWords } from '../fun/getAllOwnedWords'\nimport { selectWordInfo } from './selectWordInfo'\nimport { selectBoard } from './simpleSelectors'\n\nexport const selectAllOwnedWords = createSelector(\n\t[selectBoard, selectWordInfo],\n\tgetAllOwnedWords,\n)\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { TBoard } from '../model/Board'\nimport { IField } from '../model/Field'\nimport { IWordInfo } from '../model/IWordInfo'\nimport { getFieldIndexOffset } from './getNextFieldIndex'\nimport { getWordAt } from './getWordAt'\nimport { theOtherDirection } from './theOtherDirection'\n\nexport function getAllOwnedWords(\n\tboard: TBoard,\n\t{ firstFieldIndex, lastFieldIndex, direction }: IWordInfo,\n): IField[][] {\n\tconst words: IField[][] = []\n\tif (\n\t\t!isUndefinedOrNull(firstFieldIndex) &&\n\t\t!isUndefinedOrNull(lastFieldIndex) &&\n\t\t!isUndefinedOrNull(direction)\n\t) {\n\t\twords.push(getWordAt(board, firstFieldIndex, direction).word)\n\t\tlet fieldIndex = firstFieldIndex\n\t\tlet field = board[fieldIndex]\n\t\twhile (field && field.tile) {\n\t\t\tif (field.tile.isOwned) {\n\t\t\t\twords.push(\n\t\t\t\t\tgetWordAt(board, fieldIndex, theOtherDirection(direction))\n\t\t\t\t\t\t.word,\n\t\t\t\t)\n\t\t\t}\n\t\t\tfieldIndex += getFieldIndexOffset(direction)\n\t\t\tif (fieldIndex > lastFieldIndex) break\n\t\t\tfield = board[fieldIndex]\n\t\t}\n\t}\n\treturn words.filter(_ => _.length > 0)\n}\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { createSelector } from 'reselect'\nimport { getWordString } from '../fun/getWordString'\nimport { isWordStringValid } from '../fun/isWordStringValid'\nimport { CENTER_FIELD_INDEX } from '../model/Constants'\nimport { FieldKind } from '../model/FieldKind'\nimport { MoveError } from '../model/MoveError'\nimport { selectAllOwnedWords } from './selectAllOwnedWords'\nimport { selectWordInfo } from './selectWordInfo'\nimport { selectBoard } from './simpleSelectors'\n\nexport const selectMoveErrors = createSelector(\n\t[selectBoard, selectAllOwnedWords, selectWordInfo],\n\t(board, words, { firstFieldIndex, lastFieldIndex, direction }) => {\n\t\tconst errors: Set<MoveError> = new Set()\n\t\tif (isUndefinedOrNull(firstFieldIndex)) {\n\t\t\terrors.add(MoveError.NoTile)\n\t\t}\n\t\tif (errors.size === 0) {\n\t\t\tif (firstFieldIndex === lastFieldIndex) {\n\t\t\t\terrors.add(MoveError.OneTile)\n\t\t\t}\n\t\t\tif (errors.size === 0) {\n\t\t\t\tif (isUndefinedOrNull(direction)) {\n\t\t\t\t\terrors.add(MoveError.NoDirection)\n\t\t\t\t}\n\t\t\t\tif (errors.size === 0) {\n\t\t\t\t\tlet touchesStart = false\n\t\t\t\t\tlet touchesUnowned = false\n\t\t\t\t\tfor (const word of words) {\n\t\t\t\t\t\tif (!isWordStringValid(getWordString(word))) {\n\t\t\t\t\t\t\terrors.add(MoveError.InvalidWord)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const field of word) {\n\t\t\t\t\t\t\tif (field.kind === FieldKind.Start) {\n\t\t\t\t\t\t\t\ttouchesStart = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field.tile && !field.tile.isOwned) {\n\t\t\t\t\t\t\t\ttouchesUnowned = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isUndefinedOrNull(board[CENTER_FIELD_INDEX].tile)) {\n\t\t\t\t\t\terrors.add(MoveError.NoStart)\n\t\t\t\t\t} else if (!touchesUnowned && !touchesStart) {\n\t\t\t\t\t\terrors.add(MoveError.NoConnection)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Array.from(errors)\n\t},\n)\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { IAppState } from '../model/AppState'\nimport { MoveError } from '../model/MoveError'\nimport { selectMoveErrors } from '../select/selectMoveErrors'\nimport { DispatchProp } from './DispatchProp'\nimport './ErrorsComp.css'\n\ninterface ErrorsCompPropsFromState {\n\terrors: MoveError[]\n}\nexport interface ErrorsCompProps\n\textends ErrorsCompPropsFromState,\n\t\tDispatchProp {}\n\nexport const ErrorsComp = connect(\n\t(state: IAppState): ErrorsCompPropsFromState => ({\n\t\terrors: selectMoveErrors(state),\n\t}),\n)(({ dispatch, errors }: ErrorsCompProps) => {\n\treturn (\n\t\t<>\n\t\t\t{errors.length > 0 && (\n\t\t\t\t<div className='errors'>\n\t\t\t\t\t{Array.from(errors)\n\t\t\t\t\t\t.map(e => {\n\t\t\t\t\t\t\tswitch (e) {\n\t\t\t\t\t\t\t\tcase MoveError.InvalidWord:\n\t\t\t\t\t\t\t\t\treturn `Van egy érvénytelen szavad!`\n\t\t\t\t\t\t\t\tcase MoveError.NoConnection:\n\t\t\t\t\t\t\t\t\treturn `Kapcsolódnod kell a meglévő lapkákhoz!`\n\t\t\t\t\t\t\t\tcase MoveError.NoDirection:\n\t\t\t\t\t\t\t\t\treturn `Egy vonalba tedd a lapkáid, hézag nélkül!`\n\t\t\t\t\t\t\t\tcase MoveError.NoStart:\n\t\t\t\t\t\t\t\t\treturn `Érintened kell a Start mezőt!`\n\t\t\t\t\t\t\t\tcase MoveError.NoTile:\n\t\t\t\t\t\t\t\t\treturn `Tégy le egy lapkát!`\n\t\t\t\t\t\t\t\tcase MoveError.OneTile:\n\t\t\t\t\t\t\t\t\treturn `Egy érvényes szóhoz legalább két lapka kell!`\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\treturn `[ppy6tx]: ${e}`\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.map((e, index) => (\n\t\t\t\t\t\t\t<div key={index}>{e}</div>\n\t\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</>\n\t)\n})\n","import { createSelector } from 'reselect'\nimport { Mode } from '../model/Mode'\nimport { IPlayer } from '../model/Player'\nimport { selectMode, selectPlayers } from './simpleSelectors'\n\nexport const selectWinners = createSelector(\n\t[selectPlayers, selectMode],\n\t(players, mode) => {\n\t\tif (mode !== Mode.Ended) return []\n\t\tlet winningScore = -1\n\t\tlet winners: IPlayer[] = []\n\t\tfor (let player of players) {\n\t\t\tif (player.score > winningScore) {\n\t\t\t\twinningScore = player.score\n\t\t\t\twinners = [player]\n\t\t\t} else if (player.score === winningScore) {\n\t\t\t\twinners.push(player)\n\t\t\t}\n\t\t}\n\t\treturn winners\n\t},\n)\n","import { createSelector } from 'reselect'\nimport { selectWinners } from './selectWinners'\nimport { selectPlayers } from './simpleSelectors'\n\nexport const selectIsGameDrawn = createSelector(\n\t[selectPlayers, selectWinners],\n\t(players, winners) => {\n\t\treturn players.length === winners.length\n\t},\n)\n","import { createSelector } from 'reselect'\nimport { selectWinners } from './selectWinners'\n\nexport const selectWinnersNames = createSelector(\n\t[selectWinners],\n\twinners => {\n\t\tif (winners.length === 0) return ``\n\t\tconst winnerNames = winners.map(winner => winner.name)\n\t\tconst last = winnerNames[winnerNames.length - 1]\n\t\tconst rest = winnerNames.slice(0, winnerNames.length - 1)\n\t\treturn rest.length ? `${rest.join(', ')} és ${last}` : last\n\t},\n)\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { setPlayerName } from '../action/actions'\nimport { saveGameThunk } from '../action/saveGameThunk'\nimport { numberToSignedString } from '../fun/numberToSignedString'\nimport { IAppState } from '../model/AppState'\nimport { TPlayers } from '../model/Player'\nimport { selectPlayers } from '../select/simpleSelectors'\nimport { DispatchProp } from './DispatchProp'\nimport './PlayersComp.css'\n\nexport interface PlayersCompPropsFromStore {\n\tplayers: TPlayers\n\tplayerIndex: number | null\n\tplayerBonuses: ReadonlyArray<number> | null\n}\nexport interface PlayersCompProps\n\textends PlayersCompPropsFromStore,\n\t\tDispatchProp {\n\tisEnabled?: boolean\n}\n\nexport const PlayersComp = connect(\n\t(state: IAppState): PlayersCompPropsFromStore => ({\n\t\tplayers: selectPlayers(state),\n\t\tplayerIndex: state.playerIndex,\n\t\tplayerBonuses: state.playerBonuses,\n\t}),\n)(\n\t({\n\t\tplayers,\n\t\tplayerIndex,\n\t\tplayerBonuses,\n\t\tdispatch,\n\t\tisEnabled,\n\t}: PlayersCompProps) => {\n\t\treturn (\n\t\t\t<table className='players'>\n\t\t\t\t<tbody>\n\t\t\t\t\t{players.map((player, aPlayerIndex) => (\n\t\t\t\t\t\t<tr className='player' key={aPlayerIndex}>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t{isEnabled ? (\n\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\tclassName='player-name-button'\n\t\t\t\t\t\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\t\t\t\t\t\tconst name = prompt(`Mi a neved?`)\n\t\t\t\t\t\t\t\t\t\t\tif (name && name.trim()) {\n\t\t\t\t\t\t\t\t\t\t\t\tdispatch(\n\t\t\t\t\t\t\t\t\t\t\t\t\tsetPlayerName({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tplayerIndex: aPlayerIndex,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: name.trim(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\tdispatch(saveGameThunk())\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{player.name}\n\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\tplayer.name\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t{isEnabled && (\n\t\t\t\t\t\t\t\t<td>{aPlayerIndex === playerIndex && `•`}</td>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t{player.score}\n\t\t\t\t\t\t\t\t{` `}\n\t\t\t\t\t\t\t\t{`pont`}\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t{playerBonuses && (\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<div className='player-bonus'>\n\t\t\t\t\t\t\t\t\t\t{numberToSignedString(\n\t\t\t\t\t\t\t\t\t\t\tplayerBonuses[aPlayerIndex],\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t{` `}\n\t\t\t\t\t\t\t\t\t\t{`pont`}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t))}\n\t\t\t\t</tbody>\n\t\t\t</table>\n\t\t)\n\t},\n)\n","export function numberToSignedString(n: number) {\n\tif (n >= 0) return `+${n}`\n\telse return n + ''\n}\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { newGameThunk } from '../action/newGameThunk'\nimport { IAppState } from '../model/AppState'\nimport { Mode } from '../model/Mode'\nimport { selectIsGameDrawn } from '../select/selectIsGameDrawn'\nimport { selectWinnersNames } from '../select/selectWinnersNames'\nimport { selectMode } from '../select/simpleSelectors'\nimport { DispatchProp } from './DispatchProp'\nimport { PlayersComp } from './PlayersComp'\n\nexport interface GameEndedCompPropsFromStore {\n\tmode: Mode\n\twinnerName: string\n\tisGameDrawn: boolean\n}\nexport interface GameEndedCompProps\n\textends GameEndedCompPropsFromStore,\n\t\tDispatchProp {}\n\nexport const GameEndedComp = connect(\n\t(state: IAppState): GameEndedCompPropsFromStore => ({\n\t\tmode: selectMode(state),\n\t\tisGameDrawn: selectIsGameDrawn(state),\n\t\twinnerName: selectWinnersNames(state),\n\t}),\n)(({ dispatch, mode, winnerName, isGameDrawn }: GameEndedCompProps) => {\n\treturn (\n\t\t<>\n\t\t\t<div>{isGameDrawn ? `Döntetlen!` : `${winnerName} győzött!`}</div>\n\t\t\t<PlayersComp />\n\t\t\t<button\n\t\t\t\tonClick={e => {\n\t\t\t\t\tdispatch(newGameThunk())\n\t\t\t\t}}\n\t\t\t>{`Új játék`}</button>\n\t\t</>\n\t)\n})\n","export enum AddWordContext {\n\tRequest = 'request',\n\tFlag = 'flag',\n}\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { isNullOrUndefined } from 'util'\nimport { selectHandThunk } from '../action/selectHandThunk'\nimport { IAppState } from '../model/AppState'\nimport { TBoard } from '../model/Board'\nimport { THandIndicesToReplace } from '../model/HandIndicesToReplace'\nimport { THands } from '../model/Hands'\nimport { Mode } from '../model/Mode'\nimport {\n\tselectBoard,\n\tselectHandIndicesToReplace,\n\tselectHands,\n\tselectMode,\n} from '../select/simpleSelectors'\nimport { AspectComp } from './AspectComp'\nimport { DispatchProp } from './DispatchProp'\nimport './HandComp.css'\nimport { TileComp } from './TileComp'\n\ninterface HandCompPropsFromState {\n\thands: THands\n\tplayerIndex: number | null\n\thandIndex: number | null\n\tboard: TBoard\n\tfieldIndex: number | null\n\tmode: Mode\n\thandIndicesToReplace: THandIndicesToReplace\n}\nexport interface HandCompProps extends HandCompPropsFromState, DispatchProp {}\n\nexport const HandComp = connect(\n\t(state: IAppState): HandCompPropsFromState => ({\n\t\thands: selectHands(state),\n\t\tplayerIndex: state.playerIndex,\n\t\thandIndex: state.handIndex,\n\t\tfieldIndex: state.fieldIndex,\n\t\tboard: selectBoard(state),\n\t\thandIndicesToReplace: selectHandIndicesToReplace(state),\n\t\tmode: selectMode(state),\n\t}),\n)(\n\t({\n\t\tboard,\n\t\tdispatch,\n\t\tfieldIndex,\n\t\thandIndex,\n\t\thandIndicesToReplace,\n\t\thands,\n\t\tmode,\n\t\tplayerIndex,\n\t}: HandCompProps) => {\n\t\treturn (\n\t\t\t<>\n\t\t\t\t{!isNullOrUndefined(playerIndex) && (\n\t\t\t\t\t<div className='hand'>\n\t\t\t\t\t\t{hands[playerIndex].map((tile, aHandIndex) => (\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tkey={aHandIndex}\n\t\t\t\t\t\t\t\tclassName={[\n\t\t\t\t\t\t\t\t\t'hand-slot',\n\t\t\t\t\t\t\t\t\thandIndex === aHandIndex && 'is-selected',\n\t\t\t\t\t\t\t\t\thandIndicesToReplace[aHandIndex] &&\n\t\t\t\t\t\t\t\t\t\t'is-to-be-replaced',\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t\t\t\t\t.join(' ')}\n\t\t\t\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\t\t\t\tdispatch(selectHandThunk(aHandIndex))\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<AspectComp width={1} height={1}>\n\t\t\t\t\t\t\t\t\t{tile && (\n\t\t\t\t\t\t\t\t\t\t<TileComp tile={tile} neverOwned />\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</AspectComp>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</>\n\t\t)\n\t},\n)\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { Mode } from '../model/Mode'\nimport {\n\tselectHand,\n\tswapHandAndBoard,\n\tswapHands,\n\ttoggleHandIndexToReplace,\n} from './actions'\nimport { ThunkValue } from './ThunkValue'\n\nexport function selectHandThunk(handIndexToSelect: number): ThunkValue {\n\treturn (dispatch, getState) => {\n\t\tconst {\n\t\t\tmode,\n\t\t\tfieldIndex,\n\t\t\tboard,\n\t\t\thandIndex,\n\t\t\thands,\n\t\t\tplayerIndex,\n\t\t} = getState()\n\t\tif (mode === Mode.ReplaceTiles) {\n\t\t\tdispatch(\n\t\t\t\ttoggleHandIndexToReplace({\n\t\t\t\t\thandIndex: handIndexToSelect,\n\t\t\t\t}),\n\t\t\t)\n\t\t} else {\n\t\t\tconst field = fieldIndex ? board[fieldIndex] : null\n\t\t\tconst tile = field && field.tile\n\t\t\tif (field && tile && tile.isOwned) {\n\t\t\t\tdispatch(\n\t\t\t\t\tswapHandAndBoard({\n\t\t\t\t\t\thandIndex: handIndexToSelect,\n\t\t\t\t\t\tfieldIndex: fieldIndex!,\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tif (handIndex === handIndexToSelect) {\n\t\t\t\t\tdispatch(\n\t\t\t\t\t\tselectHand({\n\t\t\t\t\t\t\thandIndex: null,\n\t\t\t\t\t\t}),\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tif (isUndefinedOrNull(handIndex)) {\n\t\t\t\t\t\tdispatch(\n\t\t\t\t\t\t\tselectHand({\n\t\t\t\t\t\t\t\thandIndex: hands[playerIndex!][\n\t\t\t\t\t\t\t\t\thandIndexToSelect\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t? handIndexToSelect\n\t\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdispatch(\n\t\t\t\t\t\t\tswapHands({\n\t\t\t\t\t\t\t\thandIndexA: handIndex,\n\t\t\t\t\t\t\t\thandIndexB: handIndexToSelect,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { createSelector } from 'reselect'\nimport { getWordString } from '../fun/getWordString'\nimport { isWordStringValid } from '../fun/isWordStringValid'\nimport { IField } from '../model/Field'\nimport { IValidAndInvalidWords } from '../model/IValidAndInvalidWords'\nimport { selectAllOwnedWords } from './selectAllOwnedWords'\n\nexport const selectOwnValidAndInvalidWords = createSelector(\n\t[selectAllOwnedWords],\n\t(words: IField[][]): IValidAndInvalidWords | null => {\n\t\tconst valid: IField[][] = []\n\t\tconst invalid: IField[][] = []\n\t\tfor (let word of words) {\n\t\t\tif (isWordStringValid(getWordString(word))) {\n\t\t\t\tvalid.push(word)\n\t\t\t} else {\n\t\t\t\tinvalid.push(word)\n\t\t\t}\n\t\t}\n\t\tif (valid.length > 0 || invalid.length > 0) {\n\t\t\treturn {\n\t\t\t\tvalid,\n\t\t\t\tinvalid,\n\t\t\t}\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t},\n)\n","import { IField } from '../model/Field'\nimport { FieldKind } from '../model/FieldKind'\n\nexport function getWordScore(word: ReadonlyArray<IField>): number {\n\tlet wordMulti = 1\n\treturn (\n\t\tword.reduce((sum, field) => {\n\t\t\tconst tile = field.tile\n\t\t\tlet tileScore = 0\n\t\t\tif (tile) {\n\t\t\t\ttileScore = tile.score\n\t\t\t\tif (tile.isOwned) {\n\t\t\t\t\tswitch (field.kind) {\n\t\t\t\t\t\tcase FieldKind.DoubleLetter:\n\t\t\t\t\t\t\ttileScore *= 2\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase FieldKind.TripleLetter:\n\t\t\t\t\t\t\ttileScore *= 3\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase FieldKind.Start:\n\t\t\t\t\t\tcase FieldKind.DoubleWord:\n\t\t\t\t\t\t\twordMulti *= 2\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase FieldKind.TripleWord:\n\t\t\t\t\t\t\twordMulti *= 3\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum + tileScore\n\t\t}, 0) * wordMulti\n\t)\n}\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { AddWordContext } from '../model/AddWordContext'\nimport { addWordRequestThunk } from '../action/addWordRequestThunk'\nimport { getWordScore } from '../fun/getWordScore'\nimport { getWordString } from '../fun/getWordString'\nimport { IAppState } from '../model/AppState'\nimport { IField } from '../model/Field'\nimport { DispatchProp } from './DispatchProp'\n\nexport interface WordListCompPropsFromStore {}\nexport interface WordListCompProps\n\textends WordListCompPropsFromStore,\n\t\tDispatchProp {\n\twords: ReadonlyArray<ReadonlyArray<IField>>\n\tshowScore?: boolean\n\twordClassName?: string\n\tscoreClassName?: string\n\taddWordContext?: AddWordContext\n\tlabel: React.ReactChild\n}\n\nexport const WordListComp = connect(\n\t(state: IAppState): WordListCompPropsFromStore => ({}),\n)(\n\t({\n\t\twords,\n\t\tshowScore,\n\t\twordClassName,\n\t\tscoreClassName,\n\t\taddWordContext,\n\t\tlabel,\n\t\tdispatch,\n\t}: WordListCompProps) => {\n\t\treturn (\n\t\t\t<>\n\t\t\t\t{words.length > 0 && (\n\t\t\t\t\t<div>\n\t\t\t\t\t\t{label}\n\t\t\t\t\t\t{`: `}\n\t\t\t\t\t\t{words.map((word, index) => {\n\t\t\t\t\t\t\tconst wordString = getWordString(word)\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<React.Fragment key={index}>\n\t\t\t\t\t\t\t\t\t{index > 0 && <>{`, `}</>}\n\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\tclassName={wordClassName}\n\t\t\t\t\t\t\t\t\t\thref={`http://ertelmezo.oszk.hu/kereses.php?csakcimben=on&kereses=${encodeURIComponent(\n\t\t\t\t\t\t\t\t\t\t\t`\"${wordString}\"`,\n\t\t\t\t\t\t\t\t\t\t)}`}\n\t\t\t\t\t\t\t\t\t\ttarget='_blank'\n\t\t\t\t\t\t\t\t\t\trel='noopener noreferrer'\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{wordString.replace(' ', ' ')}\n\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t{showScore && (\n\t\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t\t{` `}\n\t\t\t\t\t\t\t\t\t\t\t<span className={scoreClassName}>\n\t\t\t\t\t\t\t\t\t\t\t\t{getWordScore(word)}\n\t\t\t\t\t\t\t\t\t\t\t\t{` `}\n\t\t\t\t\t\t\t\t\t\t\t\t{`pont`}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t{addWordContext && (\n\t\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t\t{` `}\n\t\t\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdispatch(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taddWordRequestThunk(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddWordContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twordString,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t{addWordContext ===\n\t\t\t\t\t\t\t\t\t\t\t\tAddWordContext.Request\n\t\t\t\t\t\t\t\t\t\t\t\t\t? `Kérem`\n\t\t\t\t\t\t\t\t\t\t\t\t\t: `Jelzem`}\n\t\t\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</React.Fragment>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</>\n\t\t)\n\t},\n)\n","import { AddWordContext } from '../model/AddWordContext'\nimport { ThunkValue } from './ThunkValue'\n\nexport function addWordRequestThunk(\n\tcontext: AddWordContext,\n\tword: string,\n): ThunkValue {\n\treturn (dispatch, getState) => {\n\t\tif (\n\t\t\twindow.confirm(`Itt jelezheted nekem, hogy a kiválasztott „${word}” ${\n\t\t\t\tcontext === AddWordContext.Request\n\t\t\t\t\t? `szót szeretnéd érvényessé tenni a játékban.`\n\t\t\t\t\t: `szó nem szabályos.`\n\t\t\t}\n\nFONTOS:\n- Ha ige, csak az egyes szám harmadik személyű alakja (pl. eszik, megy, tesz) szabályos.\n- Ha főnév, csak ragozatlan alakban (pl. asztal, szék, zimankó) szabályos.\n- Ha melléknév, akkor csak az alapesetű alakban (pl. egész, kerek, szép) szabályos.\n- Ritka szavakat csak akkor fogadok el, ha van szócikkük a Wikiszótárban vagy a Wikipédián.\n- Trágárságot nem fogadok el.\n- Időbe telik – napok, hetek, hónapok, ki tudja? Légy türelmes!\n- Az én döntésem, hogy mit fogadok el. Légy megértő!`)\n\t\t) {\n\t\t\tfetch('https://prwxi9.herokuapp.com/add-word', {\n\t\t\t\tmethod: 'POST',\n\t\t\t\tmode: 'cors',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t},\n\t\t\t\tbody: `context=${encodeURIComponent(\n\t\t\t\t\tcontext,\n\t\t\t\t)}&word=${encodeURIComponent(word)}`,\n\t\t\t})\n\t\t\t\t.then(response => response.json())\n\t\t\t\t.then((response: { result: number; error: string }) => {\n\t\t\t\t\tif (response.error) {\n\t\t\t\t\t\tthrow response.error\n\t\t\t\t\t}\n\t\t\t\t\twindow.alert(\n\t\t\t\t\t\tresponse.result > 0\n\t\t\t\t\t\t\t? `Sikerült, köszönöm a visszajelzést!`\n\t\t\t\t\t\t\t: `Ez a szó már rajta van a listámon, de azért köszönöm!`,\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.catch(e => {\n\t\t\t\t\twindow.alert((e + '').replace(/^Error:\\s*/g, ''))\n\t\t\t\t})\n\t\t}\n\t}\n}\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { AddWordContext } from '../model/AddWordContext'\nimport { IAppState } from '../model/AppState'\nimport { IValidAndInvalidWords } from '../model/IValidAndInvalidWords'\nimport { selectOwnValidAndInvalidWords } from '../select/selectOwnValidAndInvalidWords'\nimport { DispatchProp } from './DispatchProp'\nimport './OwnWordInfoComp.css'\nimport { WordListComp } from './WordListComp'\n\nexport interface OwnWordInfoCompPropsFromStore {\n\twords: IValidAndInvalidWords | null\n}\nexport interface OwnWordInfoCompProps\n\textends OwnWordInfoCompPropsFromStore,\n\t\tDispatchProp {}\n\nexport const OwnWordInfoComp = connect(\n\t(state: IAppState): OwnWordInfoCompPropsFromStore => ({\n\t\twords: selectOwnValidAndInvalidWords(state),\n\t}),\n)(({ words, dispatch }: OwnWordInfoCompProps) => {\n\treturn (\n\t\t<>\n\t\t\t{words && (\n\t\t\t\t<div className='own-word-info'>\n\t\t\t\t\t<WordListComp\n\t\t\t\t\t\twords={words.valid}\n\t\t\t\t\t\tlabel={`Érvényes szavak`}\n\t\t\t\t\t\tshowScore\n\t\t\t\t\t\twordClassName='valid-word'\n\t\t\t\t\t\tscoreClassName='word-score'\n\t\t\t\t\t\taddWordContext={AddWordContext.Flag}\n\t\t\t\t\t/>\n\t\t\t\t\t<WordListComp\n\t\t\t\t\t\twords={words.invalid}\n\t\t\t\t\t\tlabel={`Érvényetelen szavak`}\n\t\t\t\t\t\twordClassName='invalid-word'\n\t\t\t\t\t\taddWordContext={AddWordContext.Request}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</>\n\t)\n})\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { createSelector } from 'reselect'\nimport { getWordAt } from '../fun/getWordAt'\nimport { getWordString } from '../fun/getWordString'\nimport { isWordStringValid } from '../fun/isWordStringValid'\nimport { Direction } from '../model/Direction'\nimport { IField } from '../model/Field'\nimport { IValidAndInvalidWords } from '../model/IValidAndInvalidWords'\nimport { selectBoard, selectFieldIndex } from './simpleSelectors'\n\nexport const selectPlacedValidAndInvalidWords = createSelector(\n\t[selectFieldIndex, selectBoard],\n\t(fieldIndex, board): IValidAndInvalidWords | null => {\n\t\tif (isUndefinedOrNull(fieldIndex)) return null\n\t\tconst field = board[fieldIndex]\n\t\tif (!field || !field.tile || field.tile.isOwned) return null\n\t\tconst words = [\n\t\t\tgetWordAt(board, fieldIndex, Direction.Horizontal).word,\n\t\t\tgetWordAt(board, fieldIndex, Direction.Vertical).word,\n\t\t].filter(word => word.length > 1)\n\t\tconst valid: IField[][] = []\n\t\tconst invalid: IField[][] = []\n\t\tfor (let word of words) {\n\t\t\tif (isWordStringValid(getWordString(word))) {\n\t\t\t\tvalid.push(word)\n\t\t\t} else {\n\t\t\t\tinvalid.push(word)\n\t\t\t}\n\t\t}\n\t\tif (valid.length > 0 || invalid.length > 0) {\n\t\t\treturn {\n\t\t\t\tvalid,\n\t\t\t\tinvalid,\n\t\t\t}\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t},\n)\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { AddWordContext } from '../model/AddWordContext'\nimport { IAppState } from '../model/AppState'\nimport { IValidAndInvalidWords } from '../model/IValidAndInvalidWords'\nimport { selectPlacedValidAndInvalidWords } from '../select/selectPlacedValidAndInvalidWords'\nimport { DispatchProp } from './DispatchProp'\nimport './PlacedWordInfoComp.css'\nimport { WordListComp } from './WordListComp'\n\nexport interface PlacedWordInfoCompPropsFromStore {\n\twords: IValidAndInvalidWords | null\n}\nexport interface PlacedWordInfoCompProps\n\textends PlacedWordInfoCompPropsFromStore,\n\t\tDispatchProp {}\n\nexport const PlacedWordInfoComp = connect(\n\t(state: IAppState): PlacedWordInfoCompPropsFromStore => ({\n\t\twords: selectPlacedValidAndInvalidWords(state),\n\t}),\n)(({ words, dispatch }: PlacedWordInfoCompProps) => {\n\treturn (\n\t\t<>\n\t\t\t{words && (\n\t\t\t\t<div className='placed-word-info'>\n\t\t\t\t\t<WordListComp\n\t\t\t\t\t\twords={words.valid}\n\t\t\t\t\t\tlabel={`Szavak a választott mezőn`}\n\t\t\t\t\t\taddWordContext={AddWordContext.Flag}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</>\n\t)\n})\n","import { createSelector } from 'reselect'\nimport { getWordScore } from '../fun/getWordScore'\nimport { BINGO_SCORE } from '../model/Constants'\nimport { selectIsBingo } from './selectIsBingo'\nimport { selectOwnValidAndInvalidWords } from './selectOwnValidAndInvalidWords'\n\nexport const selectMoveScore = createSelector(\n\t[selectOwnValidAndInvalidWords, selectIsBingo],\n\t(words, isBingo): number => {\n\t\tlet score = 0\n\t\tif (words) {\n\t\t\tfor (let word of words.valid) {\n\t\t\t\tscore += getWordScore(word)\n\t\t\t}\n\t\t\tif (words.valid.length && isBingo) score += BINGO_SCORE\n\t\t}\n\t\treturn score\n\t},\n)\n","import memoizee from 'memoizee'\nimport { THand } from '../model/Hands'\n\nexport const getHandValue = memoizee(\n\t(hand: THand) => {\n\t\treturn hand.reduce((sum, tile) => sum + (tile ? tile.score : 0), 0)\n\t},\n\t{ max: 2 },\n)\n","import { createSelector } from 'reselect'\nimport { getHandValue } from '../fun/getHandValue'\nimport { selectHands } from './simpleSelectors'\n\nexport const selectEmptyHandBonus = createSelector(\n\t[selectHands],\n\thands => {\n\t\treturn hands.reduce((sum, hand) => sum + getHandValue(hand), 0)\n\t},\n)\n","import { createSelector } from 'reselect'\nimport { isNull } from 'util'\nimport { getHandValue } from '../fun/getHandValue'\nimport { selectEmptyHandBonus } from './selectEmptyHandBonus'\nimport { selectHands } from './simpleSelectors'\n\nexport const selectPlayerBonuses = createSelector(\n\t[selectHands, selectEmptyHandBonus],\n\t(hands, emptyHandBonus) => {\n\t\treturn hands.map(hand => {\n\t\t\tif (hand.filter(isNull).length === 7) {\n\t\t\t\treturn emptyHandBonus\n\t\t\t} else {\n\t\t\t\treturn -getHandValue(hand)\n\t\t\t}\n\t\t})\n\t},\n)\n","import { Mode } from '../model/Mode'\nimport { selectPlayerBonuses } from '../select/selectPlayerBonuses'\nimport { scoreBonuses, setMode } from './actions'\nimport { ThunkValue } from './ThunkValue'\n\nexport function endGameThunk(): ThunkValue {\n\treturn (dispatch, getState) => {\n\t\tconst state = getState()\n\t\tdispatch(scoreBonuses(selectPlayerBonuses(state)))\n\t\tdispatch(setMode(Mode.Ended))\n\t}\n}\n","import { THand } from '../model/Hands'\nimport { getLettersInHandSet } from './getLettersInHandSet'\n\nexport function getLettersInHand(hand: THand) {\n\treturn Array.from(getLettersInHandSet(hand)).sort(\n\t\t(a, b) => a.length - b.length,\n\t)\n}\n","import { THand } from '../model/Hands'\nimport letters from '../res/letters.json'\nexport function getLettersInHandSet(hand: THand): Set<string> {\n\tconst lettersInHandSet = new Set<string>()\n\thand.forEach(tile => {\n\t\tif (tile) {\n\t\t\tif (tile.letter === ' ') {\n\t\t\t\tletters.forEach(letter => lettersInHandSet.add(letter.letter))\n\t\t\t} else {\n\t\t\t\tlettersInHandSet.add(tile.letter)\n\t\t\t}\n\t\t}\n\t})\n\tlettersInHandSet.delete(' ')\n\treturn lettersInHandSet\n}\n","import { isNumber } from 'util'\nimport { TLineParts } from '../model/LineParts'\n\nexport function partsToRegExpString(\n\tlettersInHandRe: string,\n\tparts: TLineParts,\n\t{\n\t\ttrim,\n\t}: {\n\t\ttrim?: boolean\n\t} = {},\n): string {\n\tlet reString = trim ? '' : '^'\n\tparts.forEach((part, index) => {\n\t\tif (isNumber(part)) {\n\t\t\tif (part > 0) {\n\t\t\t\tif (index === 0 || index === parts.length - 1) {\n\t\t\t\t\tif (!trim) {\n\t\t\t\t\t\treString += `(${lettersInHandRe}{0,${part}})`\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treString += `(${lettersInHandRe}{${part}})`\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treString += `(${part.text})`\n\t\t}\n\t})\n\treString += trim ? '' : '$'\n\treturn reString\n}\n","import { TLineParts } from '../model/LineParts'\nimport { partsToRegExpString } from './partsToRegExpString'\n\nexport function linePartsToRegExpStrings(\n\tlettersInHandRe: string,\n\tparts: TLineParts,\n\t{\n\t\ttrim,\n\t}: {\n\t\ttrim?: boolean\n\t} = {},\n): string[] {\n\tconst result: string[] = []\n\tfor (let startIndex = 0; startIndex < parts.length - 2; startIndex += 2) {\n\t\tfor (\n\t\t\tlet endIndex = startIndex + 2;\n\t\t\tendIndex < parts.length;\n\t\t\tendIndex += 2\n\t\t) {\n\t\t\tlet subParts = parts.slice(startIndex, endIndex + 1)\n\t\t\tif (startIndex > 0) {\n\t\t\t\tsubParts[0] = Math.max(0, (subParts[0] as number) - 1)\n\t\t\t}\n\t\t\tif (endIndex < parts.length - 1) {\n\t\t\t\tconst end = subParts.length - 1\n\t\t\t\tsubParts[end] = Math.max(0, (subParts[end] as number) - 1)\n\t\t\t}\n\t\t\tresult.push(\n\t\t\t\tpartsToRegExpString(lettersInHandRe, subParts, { trim }),\n\t\t\t)\n\t\t}\n\t}\n\treturn result\n}\n","export function add(a: number, b: number) {\n\treturn a + b\n}\n","import { THand } from '../model/Hands'\n\nexport function findLetterIndexInHand(letter: string, hand: THand): number {\n\tlet result: number = NaN\n\tfor (const [index, tile] of hand.entries()) {\n\t\tif (tile != null && tile.letter === letter) {\n\t\t\tresult = index\n\t\t\tbreak\n\t\t}\n\t}\n\tif (isNaN(result)) {\n\t\tfor (const [index, tile] of hand.entries()) {\n\t\t\tif (tile != null && tile.letter === ' ') {\n\t\t\t\tresult = index\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n","import { THand } from '../model/Hands'\nimport { findLetterIndexInHand } from './findLetterIndexInHand'\nimport { getLettersInHand } from './getLettersInHand'\n\nexport function getHandIndicesForWord(\n\tword: string,\n\toriginalHand: THand,\n): number[] {\n\tlet result: number[] = []\n\tlet hand = originalHand.slice()\n\tfor (let i = 0; i < word.length; ) {\n\t\tconst wordPart = word.slice(i)\n\t\tconst lettersInHand = getLettersInHand(hand)\n\t\tif (!lettersInHand.length) {\n\t\t\tthrow new Error(`[pr6o04] Out of letters.`)\n\t\t}\n\t\tlet letter: string = ''\n\t\tfor (let letterInHand of lettersInHand) {\n\t\t\tif (wordPart.startsWith(letterInHand)) {\n\t\t\t\tletter = letterInHand\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (!letter) {\n\t\t\tthrow new Error(`[pr8z2l] No letter in hand matched.`)\n\t\t}\n\t\tconst letterIndex = findLetterIndexInHand(letter, hand)\n\t\tif (isNaN(letterIndex)) {\n\t\t\tthrow new Error(`[pr52z1] Letter not in hand: ${letter}`)\n\t\t} else {\n\t\t\tresult.push(letterIndex)\n\t\t\thand[letterIndex] = null\n\t\t}\n\t\ti += letter.length\n\t}\n\treturn result\n}\n","import { isNumber } from 'illa/Type'\nimport { Direction } from 'tty'\nimport { THand } from '../model/Hands'\nimport { IWordSlice } from '../model/IWordSlice'\nimport { TLineParts } from '../model/LineParts'\nimport { IWordPlan } from '../model/WordPlan'\nimport { add } from './add'\nimport { wordSliceAndLinePartsToWordPlanInternal } from './wordSliceAndLinePartsToWordPlanInternal'\n\nexport function wordSliceAndLinePartsToWordPlan({\n\tlineIndex,\n\tdirection,\n\twordSlice: { firstIsFixed, wordParts },\n\tlineParts,\n\thand,\n}: {\n\tlineIndex: number\n\tdirection: Direction\n\twordSlice: IWordSlice\n\tlineParts: TLineParts\n\thand: THand\n}): IWordPlan[] {\n\tconst firstFixedPart = wordParts[firstIsFixed ? 0 : 1]\n\tconst wordPlans: IWordPlan[] = []\n\tlet lineTileIndices: number[] = []\n\tlet linePartStartIndex = -1\n\tfor (const [linePartIndex, linePart] of lineParts.entries()) {\n\t\tif (isNumber(linePart)) {\n\t\t\tlineTileIndices.push(linePart)\n\t\t} else {\n\t\t\tif (linePart.text === firstFixedPart) {\n\t\t\t\tlinePartStartIndex = linePartIndex\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tlineTileIndices.push(linePart.fieldCount)\n\t\t\t}\n\t\t}\n\t}\n\tif (linePartStartIndex >= 0) {\n\t\tlet wordPlan = wordSliceAndLinePartsToWordPlanInternal({\n\t\t\tlineIndex,\n\t\t\tlineTileIndex: (firstIsFixed\n\t\t\t\t? lineTileIndices\n\t\t\t\t: lineTileIndices.slice(0, lineTileIndices.length - 1)\n\t\t\t).reduce(add, 0),\n\t\t\tdirection,\n\t\t\twordParts,\n\t\t\tlineParts: lineParts.slice(\n\t\t\t\tfirstIsFixed ? linePartStartIndex : linePartStartIndex - 1,\n\t\t\t),\n\t\t\thand,\n\t\t})\n\t\tif (wordPlan) {\n\t\t\twordPlans.push(wordPlan)\n\t\t}\n\t}\n\treturn wordPlans\n}\n","import { isNumber } from 'util'\nimport { BOARD_SIZE } from '../model/Constants'\nimport { Direction } from '../model/Direction'\nimport { THand } from '../model/Hands'\nimport { TLineParts } from '../model/LineParts'\nimport { IWordPlan } from '../model/WordPlan'\nimport { getHandIndicesForWord } from './getHandIndicesForWord'\n\nexport function wordSliceAndLinePartsToWordPlanInternal({\n\tlineIndex,\n\tlineTileIndex,\n\tdirection,\n\twordParts,\n\tlineParts,\n\thand: originalHand,\n}: {\n\tlineIndex: number\n\tlineTileIndex: number\n\tdirection: Direction\n\twordParts: ReadonlyArray<string>\n\tlineParts: TLineParts\n\thand: THand\n}): IWordPlan | null {\n\tlet hasMissingParts = false\n\tlet hand = originalHand.slice()\n\tconst wordPartsEnd = wordParts.length - 1\n\tlet tiles: number[] = []\n\tconst word = wordParts.join('')\n\t// if (word === 'aggkor') {\n\t// \tconsole.log('.')\n\t// }\n\tfor (const [index, wordPart] of wordParts.entries()) {\n\t\tconst linePart = lineParts[index]\n\t\tif (isNumber(linePart)) {\n\t\t\thasMissingParts = true\n\t\t\tlet handIndicesForWord: number[]\n\t\t\ttry {\n\t\t\t\thandIndicesForWord = getHandIndicesForWord(wordPart, hand)\n\t\t\t} catch (e) {\n\t\t\t\tif (/pr6o04|pr8z2l/.test(e)) {\n\t\t\t\t\treturn null\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (index === 0 || index === wordPartsEnd) {\n\t\t\t\tif (handIndicesForWord.length > linePart) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (handIndicesForWord.length !== linePart) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (index === 0) {\n\t\t\t\tlineTileIndex += linePart - handIndicesForWord.length\n\t\t\t}\n\t\t\ttiles.push(...handIndicesForWord)\n\t\t\thandIndicesForWord.forEach(index => (hand[index] = null))\n\t\t} else {\n\t\t\tif (wordPart !== linePart.text) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`[pr52yt] Word part is not the same as line part: ${wordPart} !== ${linePart}`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tfor (let i = 0; i < linePart.fieldCount; i++) {\n\t\t\t\ttiles.push(NaN)\n\t\t\t}\n\t\t}\n\t}\n\tif (!hasMissingParts) {\n\t\treturn null\n\t}\n\treturn {\n\t\tword,\n\t\tfieldIndex:\n\t\t\tdirection === Direction.Horizontal\n\t\t\t\t? lineIndex * BOARD_SIZE + lineTileIndex\n\t\t\t\t: lineTileIndex * BOARD_SIZE + lineIndex,\n\t\tdirection,\n\t\ttiles,\n\t\tscore: NaN,\n\t}\n}\n","import { TBoard } from '../model/Board'\nimport { Direction } from '../model/Direction'\nimport { THand } from '../model/Hands'\nimport { IWordPlan } from '../model/WordPlan'\nimport words from '../res/words.json'\nimport { getLettersInHandRe } from './getLettersInHandRe'\nimport { getLine } from './getLine'\nimport { getLineParts } from './getLineParts'\nimport { getFieldIndexOffset } from './getNextFieldIndex'\nimport { getWordAt } from './getWordAt'\nimport { getWordSlices } from './getWordSlices'\nimport { getWordString } from './getWordString'\nimport { isWordStringValid } from './isWordStringValid'\nimport { linePartsToRegExpStrings } from './linePartsToRegExpStrings'\nimport { theOtherDirection } from './theOtherDirection'\nimport { wordPlanToBoard } from './wordPlanToBoard'\nimport { wordSliceAndLinePartsToWordPlan } from './wordSliceAndLinePartsToWordPlan'\n\nexport function getPotentialWordsInLine({\n\tboard,\n\tlineIndex,\n\tdirection,\n\thand,\n}: {\n\tboard: TBoard\n\tlineIndex: number\n\tdirection: Direction\n\thand: THand\n}): IWordPlan[] {\n\tconst line = getLine(board, lineIndex, direction)\n\tif (!line.find(field => !!field.tile)) return []\n\tconst lettersInHandRe = getLettersInHandRe(hand)\n\tif (!lettersInHandRe) return []\n\tconst lineParts = getLineParts(line)\n\tconst reStrings = linePartsToRegExpStrings(lettersInHandRe, lineParts)\n\tconst reStringsTrimmed = linePartsToRegExpStrings(\n\t\tlettersInHandRe,\n\t\tlineParts,\n\t\t{ trim: true },\n\t)\n\tconst re = new RegExp(reStrings.join('|'))\n\tconst res = reStrings.map(s => new RegExp(s))\n\tconst resTrimmed = reStringsTrimmed.map(s => new RegExp(s, 'g'))\n\treturn words\n\t\t.filter(word => re.test(word))\n\t\t.map(word => {\n\t\t\tconst wordSlices = getWordSlices(word, res, resTrimmed)\n\t\t\tconst wordPlans: IWordPlan[] = []\n\t\t\tfor (const wordSlice of wordSlices) {\n\t\t\t\tconst newWordPlans = wordSliceAndLinePartsToWordPlan({\n\t\t\t\t\tlineIndex,\n\t\t\t\t\tdirection,\n\t\t\t\t\twordSlice,\n\t\t\t\t\tlineParts,\n\t\t\t\t\thand,\n\t\t\t\t})\n\t\t\t\tif (newWordPlans.length) {\n\t\t\t\t\twordPlans.push(...newWordPlans)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn wordPlans\n\t\t})\n\t\t.reduce((sum, arr) => sum.concat(arr), []) // flatMap not supported until Node 11\n\t\t.filter(wordPlan => {\n\t\t\tconst boardPlan = wordPlanToBoard(board, hand, wordPlan)\n\t\t\tfor (\n\t\t\t\tlet fieldIndex = wordPlan.fieldIndex,\n\t\t\t\t\tlastFieldIndex =\n\t\t\t\t\t\tfieldIndex +\n\t\t\t\t\t\twordPlan.tiles.length *\n\t\t\t\t\t\t\tgetFieldIndexOffset(wordPlan.direction);\n\t\t\t\tfieldIndex < lastFieldIndex;\n\t\t\t\tfieldIndex += getFieldIndexOffset(wordPlan.direction)\n\t\t\t) {\n\t\t\t\tconst word = getWordAt(\n\t\t\t\t\tboardPlan,\n\t\t\t\t\tfieldIndex,\n\t\t\t\t\ttheOtherDirection(wordPlan.direction),\n\t\t\t\t)\n\t\t\t\tif (\n\t\t\t\t\tword.word.length > 1 &&\n\t\t\t\t\t!isWordStringValid(getWordString(word.word))\n\t\t\t\t) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t})\n}\n","import { TBoard } from '../model/Board'\nimport { Direction } from '../model/Direction'\nimport { IField } from '../model/Field'\nimport { getColumnLine } from './getColumnLine'\nimport { getRowLine } from './getRowLine'\n\nexport function getLine(\n\tboard: TBoard,\n\tlineIndex: number,\n\tdirection: Direction,\n): IField[] {\n\treturn direction === Direction.Horizontal\n\t\t? getRowLine(board, lineIndex)\n\t\t: getColumnLine(board, lineIndex)\n}\n","import { THand } from '../model/Hands'\nimport { getLettersInHand } from './getLettersInHand'\n\nexport function getLettersInHandRe(hand: THand): string {\n\tconst lettersInHand: string[] = getLettersInHand(hand)\n\tif (lettersInHand.length) {\n\t\treturn `(?:${lettersInHand.join('|')})`\n\t} else {\n\t\treturn ''\n\t}\n}\n","import { withInterface } from 'illa/Type'\nimport { Draft } from 'immer'\nimport { isNumber } from 'util'\nimport { IField } from '../model/Field'\nimport { IFixedLinePart } from '../model/IFixedLinePart'\nimport { TLineParts } from '../model/LineParts'\n\nexport function getLineParts(line: ReadonlyArray<IField>) {\n\tlet parts: Draft<TLineParts> = []\n\tlet wasGap = false\n\tlet lastGapStartIndex = -1\n\tline.forEach((field, index) => {\n\t\tif (field.tile) {\n\t\t\tif (wasGap) {\n\t\t\t\tif (lastGapStartIndex >= 0) {\n\t\t\t\t\tparts.push(index - lastGapStartIndex)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (wasGap || index === 0) {\n\t\t\t\tparts.push(\n\t\t\t\t\twithInterface<IFixedLinePart>({\n\t\t\t\t\t\ttext: field.tile.letter,\n\t\t\t\t\t\tfieldCount: 1,\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tconst fixedLinePart = parts[parts.length - 1] as IFixedLinePart\n\t\t\t\tfixedLinePart.text += field.tile.letter\n\t\t\t\tfixedLinePart.fieldCount++\n\t\t\t}\n\t\t\twasGap = false\n\t\t} else {\n\t\t\tif (!wasGap) {\n\t\t\t\twasGap = true\n\t\t\t\tlastGapStartIndex = index\n\t\t\t}\n\t\t}\n\t})\n\tparts.push(wasGap ? line.length - lastGapStartIndex : 0)\n\tif (!isNumber(parts[0])) parts.unshift(0)\n\tif (!isNumber(parts[parts.length - 1])) parts.push(0)\n\treturn parts\n}\n","import { IWordSlice } from '../model/IWordSlice'\n\nexport function getWordSlices(\n\tword: string,\n\tres: ReadonlyArray<RegExp>,\n\tresTrimmed: ReadonlyArray<RegExp>,\n): IWordSlice[] {\n\tconst result: IWordSlice[] = []\n\tres.forEach((re, index) => {\n\t\tif (re.test(word)) {\n\t\t\tconst reTrimmed = resTrimmed[index]\n\t\t\tfor (let i = 0; i < word.length; ) {\n\t\t\t\treTrimmed.lastIndex = i\n\t\t\t\tconst r = reTrimmed.exec(word)\n\t\t\t\tif (!r) break\n\t\t\t\tconst matchStartIndex = r.index\n\t\t\t\tconst matchEndIndex = reTrimmed.lastIndex\n\t\t\t\tconst firstIsFixed = matchStartIndex === 0\n\t\t\t\tconst wordParts = r.slice(1, r.length).filter(Boolean)\n\t\t\t\tif (matchStartIndex > 0) {\n\t\t\t\t\twordParts.unshift(word.slice(0, matchStartIndex))\n\t\t\t\t}\n\t\t\t\tif (matchEndIndex < word.length) {\n\t\t\t\t\twordParts.push(word.slice(matchEndIndex))\n\t\t\t\t}\n\t\t\t\tresult.push({ firstIsFixed, wordParts })\n\t\t\t\ti = matchStartIndex + 1\n\t\t\t}\n\t\t}\n\t})\n\treturn result\n}\n","import { Draft } from 'immer'\nimport { TBoard } from '../model/Board'\nimport { THand } from '../model/Hands'\nimport { IWordPlan } from '../model/WordPlan'\nimport { getFieldIndexOffset } from './getNextFieldIndex'\n\nexport function wordPlanToBoard(\n\tboard: TBoard,\n\thand: THand,\n\twordPlan: IWordPlan,\n): TBoard {\n\tconst boardDraft: Draft<TBoard> = JSON.parse(JSON.stringify(board))\n\tconst tiles = wordPlan.tiles.map(handIndex =>\n\t\tisNaN(handIndex) ? null : JSON.parse(JSON.stringify(hand[handIndex])),\n\t)\n\tfor (let tileIndex = 0; tileIndex < tiles.length; tileIndex++) {\n\t\tconst tile = tiles[tileIndex]\n\t\tif (tile) {\n\t\t\tconst fieldIndex =\n\t\t\t\twordPlan.fieldIndex +\n\t\t\t\ttileIndex * getFieldIndexOffset(wordPlan.direction)\n\t\t\tboardDraft[fieldIndex].tile = tile\n\t\t}\n\t}\n\treturn boardDraft\n}\n","import { TBoard } from '../model/Board'\nimport { BOARD_SIZE } from '../model/Constants'\nimport { Direction } from '../model/Direction'\nimport { THand } from '../model/Hands'\nimport { IWordPlan } from '../model/WordPlan'\nimport { getPotentialWordsInLine } from './getPotentialWordsInLine'\n\nexport function getPotentialWords(options: {\n\tboard: TBoard\n\tdirection: Direction\n\thand: THand\n}) {\n\tlet wordPlans: IWordPlan[] = []\n\tfor (let lineIndex = 0; lineIndex < BOARD_SIZE; lineIndex++) {\n\t\twordPlans.push(\n\t\t\t...getPotentialWordsInLine({\n\t\t\t\t...options,\n\t\t\t\tlineIndex,\n\t\t\t}),\n\t\t)\n\t}\n\t// console.log(wordPlans)\n\treturn wordPlans\n}\n","import { get } from 'illa/FunctionUtil'\nimport * as React from 'react'\nimport { connect } from 'react-redux'\nimport { collectTiles, setJokerLetter, setMode } from '../action/actions'\nimport { doneThunk } from '../action/doneThunk'\nimport { newGameThunk } from '../action/newGameThunk'\nimport { skipThunk } from '../action/skipThunk'\nimport { getPotentialWords } from '../fun/getPotentialWords'\nimport { IAppState } from '../model/AppState'\nimport { TBag } from '../model/Bag'\nimport { TBoard } from '../model/Board'\nimport { Direction } from '../model/Direction'\nimport { THand } from '../model/Hands'\nimport { Mode } from '../model/Mode'\nimport { MoveError } from '../model/MoveError'\nimport letters from '../res/letters.json'\nimport { selectHand } from '../select/selectHand'\nimport { selectMoveErrors } from '../select/selectMoveErrors'\nimport { selectMoveScore } from '../select/selectMoveScore'\nimport { selectBag, selectBoard } from '../select/simpleSelectors'\nimport { DispatchProp } from './DispatchProp'\nimport './PlaceTileButtonsComp.css'\n\ninterface PlaceTileButtonsCompPropsFromStore {\n\tboard: TBoard\n\tfieldIndex: number | null\n\tbag: TBag\n\tmoveScore: number\n\tmoveErrors: MoveError[]\n\thand: THand | null\n}\nexport interface PlaceTileButtonsCompProps\n\textends PlaceTileButtonsCompPropsFromStore,\n\t\tDispatchProp {}\n\nexport const PlaceTileButtonsComp = connect(\n\t(state: IAppState): PlaceTileButtonsCompPropsFromStore => ({\n\t\tbag: selectBag(state),\n\t\tboard: selectBoard(state),\n\t\tfieldIndex: state.fieldIndex,\n\t\tmoveScore: selectMoveScore(state),\n\t\tmoveErrors: selectMoveErrors(state),\n\t\thand: selectHand(state),\n\t}),\n)(\n\t({\n\t\tboard,\n\t\tfieldIndex,\n\t\tbag,\n\t\tmoveScore,\n\t\tmoveErrors,\n\t\thand,\n\t\tdispatch,\n\t}: PlaceTileButtonsCompProps) => {\n\t\treturn (\n\t\t\t<div className='buttons'>\n\t\t\t\t<button\n\t\t\t\t\tdisabled={moveErrors.length > 0}\n\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\tdispatch(doneThunk())\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{`Oké`}\n\t\t\t\t\t{moveScore > 0 && (\n\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t{`: `}\n\t\t\t\t\t\t\t<small>\n\t\t\t\t\t\t\t\t{moveScore}\n\t\t\t\t\t\t\t\t{` `}\n\t\t\t\t\t\t\t\t{`pont`}\n\t\t\t\t\t\t\t</small>\n\t\t\t\t\t\t</>\n\t\t\t\t\t)}\n\t\t\t\t</button>\n\t\t\t\t<button\n\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\tdispatch(collectTiles())\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{`Szedd össze`}\n\t\t\t\t</button>\n\t\t\t\t<button\n\t\t\t\t\tdisabled={bag.length < 7}\n\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\tdispatch(collectTiles())\n\t\t\t\t\t\tdispatch(setMode(Mode.ReplaceTiles))\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{`Csere`}\n\t\t\t\t</button>\n\t\t\t\t<button\n\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\tif (window.confirm(`Biztos hogy nem teszel semmit?`)) {\n\t\t\t\t\t\t\tdispatch(skipThunk())\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{`Kihagyom`}\n\t\t\t\t</button>\n\t\t\t\t<button\n\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\twindow.confirm(\n\t\t\t\t\t\t\t\t`Biztos hogy új játékot akarsz kezdeni?`,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tdispatch(newGameThunk())\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{`Új játék`}\n\t\t\t\t</button>\n\t\t\t\t{hand != null && (\n\t\t\t\t\t<button\n\t\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\t\talert(\n\t\t\t\t\t\t\t\t`Vízszintes: ${getPotentialWords({\n\t\t\t\t\t\t\t\t\tboard,\n\t\t\t\t\t\t\t\t\tdirection: Direction.Horizontal,\n\t\t\t\t\t\t\t\t\thand,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t.map(_ => _.word)\n\t\t\t\t\t\t\t\t\t.join(', ') ||\n\t\t\t\t\t\t\t\t\t'–'}\\nFüggőleges: ${getPotentialWords({\n\t\t\t\t\t\t\t\t\tboard,\n\t\t\t\t\t\t\t\t\tdirection: Direction.Vertical,\n\t\t\t\t\t\t\t\t\thand,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t.map(_ => _.word)\n\t\t\t\t\t\t\t\t\t.join(', ') || '–'}`,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t{`Tipp`}\n\t\t\t\t\t</button>\n\t\t\t\t)}\n\t\t\t\t{get(() => board[fieldIndex!].tile!.isJoker) && (\n\t\t\t\t\t<select\n\t\t\t\t\t\tvalue={board[fieldIndex!].tile!.letter}\n\t\t\t\t\t\tonChange={e => {\n\t\t\t\t\t\t\tdispatch(setJokerLetter({ letter: e.target.value }))\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t{letters.map((letter, index) => (\n\t\t\t\t\t\t\t<option key={index}>{letter.letter}</option>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</select>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t)\n\t},\n)\n","import { selectHandCount } from '../select/selectHandCount'\nimport { selectMoveScore } from '../select/selectMoveScore'\nimport { selectBag } from '../select/simpleSelectors'\nimport { disownTiles, fillHand, resetSkipCount, score } from './actions'\nimport { endGameThunk } from './endGameThunk'\nimport { nextPlayerAndSaveThunk } from './nextPlayerAndSaveThunk'\nimport { ThunkValue } from './ThunkValue'\n\nexport function doneThunk(): ThunkValue {\n\treturn (dispatch, getState) => {\n\t\tdispatch(score(selectMoveScore(getState())))\n\t\tdispatch(disownTiles())\n\t\tdispatch(resetSkipCount())\n\t\tdispatch((dispatch, getState) => {\n\t\t\tconst state = getState()\n\t\t\tif (selectBag(state).length || selectHandCount(state)) {\n\t\t\t\tdispatch(fillHand())\n\t\t\t\tdispatch(nextPlayerAndSaveThunk())\n\t\t\t} else {\n\t\t\t\tdispatch(endGameThunk())\n\t\t\t}\n\t\t})\n\t}\n}\n","import { collectTiles, incrementSkipCount } from './actions'\nimport { endGameThunk } from './endGameThunk'\nimport { nextPlayerAndSaveThunk } from './nextPlayerAndSaveThunk'\nimport { ThunkValue } from './ThunkValue'\n\nexport function skipThunk(): ThunkValue {\n\treturn (dispatch, getState) => {\n\t\tdispatch(incrementSkipCount())\n\t\tdispatch((dispatch, getState) => {\n\t\t\tconst state = getState()\n\t\t\tif ((state.skipCount || 0) > 3) {\n\t\t\t\tdispatch(endGameThunk())\n\t\t\t} else {\n\t\t\t\tdispatch(collectTiles())\n\t\t\t\tdispatch(nextPlayerAndSaveThunk())\n\t\t\t}\n\t\t})\n\t}\n}\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport {\n\taddTilesToBag,\n\tdeselectTilesToReplace,\n\tfillHand,\n\tremoveTilesToReplaceFromHand,\n\tresetSkipCount,\n\tsetMode,\n} from '../action/actions'\nimport { nextPlayerAndSaveThunk } from '../action/nextPlayerAndSaveThunk'\nimport { IAppState } from '../model/AppState'\nimport { THandIndicesToReplace } from '../model/HandIndicesToReplace'\nimport { THands } from '../model/Hands'\nimport { Mode } from '../model/Mode'\nimport { ITile } from '../model/Tile'\nimport {\n\tselectHandIndicesToReplace,\n\tselectHands,\n} from '../select/simpleSelectors'\nimport { DispatchProp } from './DispatchProp'\n\nexport interface ReplaceTilesButtonsCompPropsFromStore {\n\thands: THands\n\tplayerIndex: number | null\n\thandIndicesToReplace: THandIndicesToReplace\n}\nexport interface ReplaceTilesButtonsCompProps\n\textends ReplaceTilesButtonsCompPropsFromStore,\n\t\tDispatchProp {}\n\nexport const ReplaceTilesButtonsComp = connect(\n\t(state: IAppState): ReplaceTilesButtonsCompPropsFromStore => ({\n\t\thandIndicesToReplace: selectHandIndicesToReplace(state),\n\t\thands: selectHands(state),\n\t\tplayerIndex: state.playerIndex,\n\t}),\n)(\n\t({\n\t\thands,\n\t\tplayerIndex,\n\t\thandIndicesToReplace,\n\t\tdispatch,\n\t}: ReplaceTilesButtonsCompProps) => {\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<button\n\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\tconst hand = hands[playerIndex!]\n\t\t\t\t\t\tconst tilesToReplace = hand.filter(\n\t\t\t\t\t\t\t(tile, aHandIndex) =>\n\t\t\t\t\t\t\t\thandIndicesToReplace[aHandIndex],\n\t\t\t\t\t\t) as ITile[]\n\t\t\t\t\t\tdispatch(removeTilesToReplaceFromHand())\n\t\t\t\t\t\tdispatch(deselectTilesToReplace())\n\t\t\t\t\t\tdispatch(fillHand())\n\t\t\t\t\t\tdispatch(addTilesToBag({ tiles: tilesToReplace }))\n\t\t\t\t\t\tdispatch(resetSkipCount())\n\t\t\t\t\t\tdispatch(setMode(Mode.PlaceTile))\n\t\t\t\t\t\tdispatch(nextPlayerAndSaveThunk())\n\t\t\t\t\t}}\n\t\t\t\t>{`Csere`}</button>\n\t\t\t\t<button\n\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\tdispatch(deselectTilesToReplace())\n\t\t\t\t\t\tdispatch(setMode(Mode.PlaceTile))\n\t\t\t\t\t}}\n\t\t\t\t>{`Mégse`}</button>\n\t\t\t</>\n\t\t)\n\t},\n)\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { loadGameThunk } from '../action/loadGameThunk'\nimport { newGameThunk } from '../action/newGameThunk'\nimport { savedGameExists } from '../fun/savedGameExists'\nimport { IAppState } from '../model/AppState'\nimport { TBag } from '../model/Bag'\nimport { BINGO_SCORE } from '../model/Constants'\nimport { Mode } from '../model/Mode'\nimport { selectIsBingo } from '../select/selectIsBingo'\nimport { selectBag, selectMode } from '../select/simpleSelectors'\nimport './AppComp.css'\nimport { BagComp } from './BagComp'\nimport { BoardComp } from './BoardComp'\nimport { DispatchProp } from './DispatchProp'\nimport { ErrorsComp } from './ErrorsComp'\nimport { GameEndedComp } from './GameEndedComp'\nimport { HandComp } from './HandComp'\nimport { OwnWordInfoComp } from './OwnWordInfoComp'\nimport { PlacedWordInfoComp } from './PlacedWordInfoComp'\nimport { PlaceTileButtonsComp } from './PlaceTileButtonsComp'\nimport { PlayersComp } from './PlayersComp'\nimport { ReplaceTilesButtonsComp } from './ReplaceTilesButtonsComp'\n\ninterface IAppCompPropsFromState {\n\tmode: Mode\n\tbag: TBag\n\tisBingo: boolean\n}\nexport interface IAppCompProps extends IAppCompPropsFromState, DispatchProp {}\n\nexport const AppComp = connect(\n\t(state: IAppState): IAppCompPropsFromState => ({\n\t\tmode: selectMode(state),\n\t\tbag: selectBag(state),\n\t\tisBingo: selectIsBingo(state),\n\t}),\n)(({ mode, bag, isBingo, dispatch }: IAppCompProps) => {\n\treturn (\n\t\t<>\n\t\t\t<BoardComp />\n\t\t\t<div className='tools'>\n\t\t\t\t{mode === Mode.NotStarted && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t{savedGameExists() && (\n\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\t\t\t\tdispatch(loadGameThunk())\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>{`Folytatás`}</button>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tonClick={e => {\n\t\t\t\t\t\t\t\tdispatch(newGameThunk())\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>{`Új játék`}</button>\n\t\t\t\t\t</>\n\t\t\t\t)}\n\t\t\t\t{mode === Mode.PlaceTile && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<PlayersComp isEnabled />\n\t\t\t\t\t\t<BagComp bag={bag} />\n\t\t\t\t\t\t<HandComp />\n\t\t\t\t\t\t{isBingo && (\n\t\t\t\t\t\t\t<div className='bingo'>{`+${BINGO_SCORE} pont!`}</div>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t<OwnWordInfoComp />\n\t\t\t\t\t\t<ErrorsComp />\n\t\t\t\t\t\t<PlaceTileButtonsComp />\n\t\t\t\t\t\t<PlacedWordInfoComp />\n\t\t\t\t\t</>\n\t\t\t\t)}\n\t\t\t\t{mode === Mode.ReplaceTiles && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<HandComp />\n\t\t\t\t\t\t<ReplaceTilesButtonsComp />\n\t\t\t\t\t</>\n\t\t\t\t)}\n\t\t\t\t{mode === Mode.Ended && <GameEndedComp />}\n\t\t\t</div>\n\t\t</>\n\t)\n})\n","import { get } from 'illa/FunctionUtil'\nimport { LocalStorageKey } from '../model/LocalStorageKey'\n\nexport function savedGameExists() {\n\treturn !!get(() => localStorage[LocalStorageKey.SavedGame])\n}\n","import { get } from 'illa/FunctionUtil'\nimport { IAppState } from '../model/AppState'\nimport { LocalStorageKey } from '../model/LocalStorageKey'\nimport { setGame } from './actions'\nimport { ThunkValue } from './ThunkValue'\n\nexport function loadGameThunk(): ThunkValue {\n\treturn (dispatch, getState) => {\n\t\tconst savedGame = get(() =>\n\t\t\tJSON.parse(localStorage[LocalStorageKey.SavedGame]),\n\t\t)\n\t\tif (savedGame) {\n\t\t\tconst game: IAppState = savedGame.app || savedGame\n\t\t\tif (game) {\n\t\t\t\tdispatch(setGame({ game }))\n\t\t\t}\n\t\t}\n\t}\n}\n","import { isUndefinedOrNull } from 'illa/Type'\nimport { Draft, produce } from 'immer'\nimport {\n\taddTilesToBag,\n\tcollectTiles,\n\tdeselectTilesToReplace,\n\tdisownTiles,\n\tfillHand,\n\tincrementSkipCount,\n\tnextPlayer,\n\tremoveTilesToReplaceFromHand,\n\tresetGame,\n\tresetSkipCount,\n\tscore,\n\tscoreBonuses,\n\tselectHand,\n\tsetGame,\n\tsetJokerLetter,\n\tsetMode,\n\tsetPlayerName,\n\tsetSelectedField,\n\tswapHandAndBoard,\n\tswapHands,\n\tswapTiles,\n\ttoggleHandIndexToReplace,\n} from '../action/actions'\nimport { TAction } from '../action/TAction'\nimport { getHandTileCount } from '../fun/getHandTileCount'\nimport { createBag, TBag } from './Bag'\nimport { createBoard, TBoard } from './Board'\nimport {\n\tcreateHandIndicesToReplace,\n\tTHandIndicesToReplace,\n} from './HandIndicesToReplace'\nimport { createHands, THands } from './Hands'\nimport { Mode } from './Mode'\nimport { createPlayers, TPlayers } from './Player'\nimport { ITile } from './Tile'\n\nexport interface IAppState {\n\treadonly mode: Mode\n\treadonly players: TPlayers\n\treadonly playerIndex: number | null\n\treadonly board: TBoard\n\treadonly bag: TBag\n\treadonly fieldIndex: number | null\n\treadonly handIndex: number | null\n\treadonly hands: THands\n\treadonly handIndicesToReplace: THandIndicesToReplace\n\treadonly startingHandCount: number | null\n\treadonly skipCount: number | null\n\treadonly playerBonuses: ReadonlyArray<number> | null\n}\n\nexport function createAppState(): IAppState {\n\treturn {\n\t\tmode: Mode.NotStarted,\n\t\tboard: createBoard(),\n\t\tbag: createBag(),\n\t\thands: createHands(),\n\t\tplayers: createPlayers(),\n\t\tplayerIndex: null,\n\t\tfieldIndex: null,\n\t\thandIndex: null,\n\t\thandIndicesToReplace: createHandIndicesToReplace(),\n\t\tstartingHandCount: null,\n\t\tskipCount: null,\n\t\tplayerBonuses: null,\n\t}\n}\n\nexport const appStateReducer = produce(\n\t(state: Draft<IAppState>, action: TAction) => {\n\t\tswitch (action.type) {\n\t\t\tcase collectTiles.type: {\n\t\t\t\tconst { board, playerIndex, hands } = state\n\t\t\t\tconst tiles: ITile[] = []\n\t\t\t\tfor (const field of board) {\n\t\t\t\t\tif (field.tile && field.tile.isOwned) {\n\t\t\t\t\t\tconst tile = field.tile\n\t\t\t\t\t\tfield.tile = null\n\t\t\t\t\t\ttiles.push(tile)\n\t\t\t\t\t\tif (tile.isJoker) tile.letter = ' '\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst hand = hands[playerIndex!]\n\t\t\t\tfor (let i = 0; i < hand.length; i++) {\n\t\t\t\t\tif (isUndefinedOrNull(hand[i])) {\n\t\t\t\t\t\thand[i] = tiles.shift() || null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase disownTiles.type: {\n\t\t\t\tfor (const field of state.board) {\n\t\t\t\t\tif (field.tile) {\n\t\t\t\t\t\tif (field.tile.isOwned) {\n\t\t\t\t\t\t\tfield.tile.isOwned = undefined\n\t\t\t\t\t\t\tfield.tile.isLast = true\n\t\t\t\t\t\t} else if (field.tile.isLast) {\n\t\t\t\t\t\t\tfield.tile.isLast = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase fillHand.type: {\n\t\t\t\tconst { bag, hands, playerIndex } = state\n\t\t\t\tconst hand = hands[playerIndex!]\n\t\t\t\tconst count = Math.min(\n\t\t\t\t\tbag.length,\n\t\t\t\t\thand.length - getHandTileCount(hand),\n\t\t\t\t)\n\t\t\t\tconst tiles: ITile[] = []\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tconst tile = bag.splice(\n\t\t\t\t\t\tMath.floor(Math.random() * bag.length),\n\t\t\t\t\t\t1,\n\t\t\t\t\t)[0]\n\t\t\t\t\ttile.isOwned = true\n\t\t\t\t\ttiles.push(tile)\n\t\t\t\t}\n\t\t\t\tconst newHand = (state.hands[playerIndex!] = hand.map(tile =>\n\t\t\t\t\ttile ? tile : tiles.shift() || null,\n\t\t\t\t))\n\t\t\t\tstate.startingHandCount = getHandTileCount(newHand)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase nextPlayer.type: {\n\t\t\t\tconst { playerIndex } = state\n\t\t\t\tstate.playerIndex = isUndefinedOrNull(playerIndex)\n\t\t\t\t\t? 0\n\t\t\t\t\t: 1 - playerIndex\n\t\t\t\tstate.fieldIndex = null\n\t\t\t\tstate.handIndex = null\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase resetGame.type:\n\t\t\t\treturn createAppState()\n\t\t\tcase score.type: {\n\t\t\t\tconst { players, playerIndex } = state\n\t\t\t\tplayers[playerIndex!].score += action.payload\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase setSelectedField.type: {\n\t\t\t\tstate.fieldIndex = action.payload.fieldIndex\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase selectHand.type: {\n\t\t\t\tstate.handIndex = action.payload.handIndex\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase setJokerLetter.type: {\n\t\t\t\tconst { board, fieldIndex } = state\n\t\t\t\tboard[fieldIndex!].tile!.letter = action.payload.letter\n\t\t\t\tstate.fieldIndex = null\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase setMode.type: {\n\t\t\t\tconst mode = action.payload\n\t\t\t\tif (mode !== state.mode) {\n\t\t\t\t\tstate.fieldIndex = null\n\t\t\t\t\tstate.handIndex = null\n\t\t\t\t}\n\t\t\t\tstate.mode = mode\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase setPlayerName.type: {\n\t\t\t\tconst { playerIndex, name } = action.payload\n\t\t\t\tstate.players[playerIndex].name = name\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase swapHandAndBoard.type: {\n\t\t\t\tconst { board, hands, playerIndex } = state\n\t\t\t\tconst { fieldIndex, handIndex } = action.payload\n\t\t\t\tconst field = board[fieldIndex]\n\t\t\t\tconst hand = hands[playerIndex!]\n\t\t\t\tconst tileOnBoard = field.tile\n\t\t\t\tconst tileInHand = hand[handIndex]\n\t\t\t\tstate.fieldIndex =\n\t\t\t\t\ttileInHand && tileInHand.isJoker ? fieldIndex : null\n\t\t\t\tstate.handIndex = null\n\t\t\t\tfield.tile = tileInHand\n\t\t\t\thand[handIndex] = tileOnBoard\n\t\t\t\tif (tileOnBoard && tileOnBoard.isJoker) {\n\t\t\t\t\ttileOnBoard.letter = ' '\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase swapHands.type: {\n\t\t\t\tconst { hands, playerIndex } = state\n\t\t\t\tconst { handIndexA, handIndexB } = action.payload\n\t\t\t\tconst hand = hands[playerIndex!]\n\t\t\t\tconst tileA = hand[handIndexA]\n\t\t\t\tconst tileB = hand[handIndexB]\n\t\t\t\tstate.handIndex = null\n\t\t\t\thand[handIndexA] = tileB\n\t\t\t\thand[handIndexB] = tileA\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase swapTiles.type: {\n\t\t\t\tconst { board } = state\n\t\t\t\tconst { fieldIndexA, fieldIndexB } = action.payload\n\t\t\t\tconst fieldATile = board[fieldIndexA].tile\n\t\t\t\tconst fieldBTile = board[fieldIndexB].tile\n\t\t\t\tstate.fieldIndex = null\n\t\t\t\tboard[fieldIndexA].tile = fieldBTile\n\t\t\t\tboard[fieldIndexB].tile = fieldATile\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase toggleHandIndexToReplace.type: {\n\t\t\t\tconst { handIndicesToReplace } = state\n\t\t\t\tconst { handIndex } = action.payload\n\t\t\t\thandIndicesToReplace[handIndex] = !handIndicesToReplace[\n\t\t\t\t\thandIndex\n\t\t\t\t]\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase removeTilesToReplaceFromHand.type: {\n\t\t\t\tconst { handIndicesToReplace, playerIndex, hands } = state\n\t\t\t\tconst hand = hands[playerIndex!]\n\t\t\t\tstate.hands[playerIndex!] = hand.map((tile, index) =>\n\t\t\t\t\thandIndicesToReplace[index] ? null : tile,\n\t\t\t\t)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase deselectTilesToReplace.type: {\n\t\t\t\tstate.handIndicesToReplace.fill(false)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase addTilesToBag.type: {\n\t\t\t\tstate.bag.push(...action.payload.tiles)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase setGame.type:\n\t\t\t\treturn action.payload.game\n\t\t\tcase incrementSkipCount.type: {\n\t\t\t\tstate.skipCount = (state.skipCount || 0) + 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase resetSkipCount.type: {\n\t\t\t\tstate.skipCount = 0\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase scoreBonuses.type: {\n\t\t\t\tstate.playerBonuses = action.payload as number[]\n\t\t\t\tstate.players.forEach((player, playerIndex) => {\n\t\t\t\t\tplayer.score += action.payload[playerIndex]\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault:\n\t\t}\n\t},\n\tcreateAppState(),\n)\n","import { withInterface } from 'illa/Type'\nimport { IField } from './Field'\nimport { FieldKind } from './FieldKind'\n\nexport type TBoard = ReadonlyArray<IField>\n\nexport function createBoard(): TBoard {\n\treturn `\nW--l---W---l--W\n-w---L---L---w-\n--w---l-l---w--\nl--w---l---w--l\n----w-----w----\n-L---L---L---L-\n--l---l-l---l--\nW--l---s---l--W\n--l---l-l---l--\n-L---L---L---L-\n----w-----w----\nl--w---l---w--l\n--w---l-l---w--\n-w---L---L---w-\nW--l---W---l--W\n`\n\t\t.trim()\n\t\t.split(/\\n/)\n\t\t.flatMap(row =>\n\t\t\trow.split('').map(letter =>\n\t\t\t\twithInterface<IField>({\n\t\t\t\t\tkind: letter as FieldKind,\n\t\t\t\t\ttile: null,\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n}\n","import { range } from 'illa/ArrayUtil'\nimport { withInterface } from 'illa/Type'\nimport letters from '../res/letters.json'\nimport { ITile } from './Tile'\n\nexport type TBag = ReadonlyArray<ITile>\n\nexport function createBag(): TBag {\n\treturn letters.flatMap(({ count, letter, score }) =>\n\t\trange(count).map(_ =>\n\t\t\twithInterface<ITile>({\n\t\t\t\tletter,\n\t\t\t\tscore,\n\t\t\t\tisOwned: undefined,\n\t\t\t\tisJoker: letter === ' ' || undefined,\n\t\t\t\tisLast: undefined,\n\t\t\t}),\n\t\t),\n\t)\n}\n","import { range } from 'illa/ArrayUtil'\nimport { ITile } from './Tile'\n\nexport type THand = ReadonlyArray<ITile | null>\nexport type THands = ReadonlyArray<THand>\n\nexport function createHands(): THands {\n\treturn range(2).map(_ => range(7).map(_ => null))\n}\n","import { range } from 'illa/ArrayUtil'\nimport { withInterface } from 'illa/Type'\n\nexport interface IPlayer {\n\tname: string\n\tscore: number\n}\n\nexport type TPlayers = ReadonlyArray<IPlayer>\n\nexport function createPlayers(): TPlayers {\n\treturn range(2).map(_ =>\n\t\twithInterface<IPlayer>({\n\t\t\tname: `${_ + 1}. Játékos`,\n\t\t\tscore: 0,\n\t\t}),\n\t)\n}\n","import { range } from 'illa/ArrayUtil'\n\nexport type THandIndicesToReplace = ReadonlyArray<boolean>\n\nexport function createHandIndicesToReplace(): THandIndicesToReplace {\n\treturn range(7).map(_ => false)\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'normalize.css'\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux'\nimport { configureStore } from 'redux-starter-kit'\nimport { AppComp } from './comp/AppComp'\nimport './index.css'\nimport { appStateReducer } from './model/AppState'\nimport * as serviceWorker from './serviceWorker'\n\nexport const store = configureStore({\n\treducer: appStateReducer,\n})\n\nReactDOM.render(\n\t<Provider store={store}>\n\t\t<AppComp />\n\t</Provider>,\n\tdocument.getElementById('root'),\n)\n\nserviceWorker.register()\n"],"sourceRoot":""}